{"version":3,"sources":["../../src/Utils/common.utils.tsx","../../src/Utils/draggable.utils.tsx","../../src/Utils/canvas.utils.tsx","../../src/index.tsx","App.tsx","index.tsx"],"names":["reversedIndexOf","length","index","arr","isDragging","dragCompIndex","offset","x","y","DestroyDraggable","canvasDOM","onMouseDown","event","cwComponents","revComponents","canvasEvent","getCanvasEvent","comp","rectCollision","triggerComponentSelect","onMouseMove","cwRender","onMouseUp","rect","canvasRect","top","CustomEvent","detail","component","canvasDefaultData","canvasData","InitCanvas","data","parentDOM","cwMode","mode","ctx","canvas","canvasRender","RegisterDraggable","window","handleComponentSelect","selectedIndex","debouncRender","func","timeout","timer","debounce","parentDim","setCanvasBG","renderComponents","drawBoxComponent","drawSelectionHandle","compDimension","w","h","strokeOffset","selectionBoxes","boxCords","i","boxCord","boxSize","getSelectionBoxCords","box","fontSize","drawRoundedRect","radius","borderRadius","tl","tr","br","bl","formatBorderRadius","onDataChange","useState","canvasRef","createRef","parentRef","useEffect","setCwMode","setCwData","parent","cwData","className","React","ref","onClick","randomX","Math","randomY","type","fillColor","text","components","App","setData","strokeColor","lineWidth","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.27de93d8.chunk.js","sourcesContent":["import { BorderRadius, BorderRadiusBase } from \"../Dtos/canvas.dtos\";\n\n/**\n * Log tag.\n */\nconst logTag = 'CanvasWorkflow:';\n\n/**\n * Debounce the given function.\n * \n * @param func Function.\n * @param timeout Timeout in ms.\n * @returns Function.\n */\nexport function debounce(func: Function, timeout = 300){\n    let timer: number;\n    return (...args: any[]) => {\n        window.clearTimeout(timer);\n        timer = window.setTimeout(() => { func.apply(this, args); }, timeout);\n    };\n}\n\n/**\n * Get reversed index of item in array.\n * \n * @param arr Arrays\n * @param item Item in array\n * @returns number\n */\nexport const reversedIndexOf = function( arr: any[], item: any){\n    const { length } = arr;\n    const index = arr.indexOf(item);\n    if(index === -1){\n       return -1;\n    };\n    return length - index - 1;\n};\n\n/**\n * Format the border radius.\n * \n * @param borderRadius BorderRadius\n * @returns BorderRadiusBase\n */\nexport const formatBorderRadius = ( borderRadius?: BorderRadius ): BorderRadiusBase => {\n    if( typeof borderRadius !== 'number' ) {\n        return { ...{ tl: 0, tr: 0, br: 0, bl: 0 }, ...borderRadius };\n    }\n    \n    return { \n        tl: borderRadius as number, \n        tr: borderRadius as number, \n        br: borderRadius as number, \n        bl: borderRadius as number \n    };\n}\n\n/**\n * Get selection box coordinates.\n * \n * @param compDimension Component Dimension.\n * @param strokeOffset Selection stroke offset.\n * @param boxSize Box size.\n * @returns Array\n */\nexport const getSelectionBoxCords = ( compDimension: { x: number, y: number, w: number, h: number }, strokeOffset: number, boxSize: number ) => {\n    let boxCords: { x: number, y: number, w: number, h: number }[] = [];\n\n    for( let i = 1; i <= 8; i++ ) {\n        let boxCord = {\n            x: 0,\n            y: 0,\n            w: boxSize,\n            h: boxSize,\n        }\n\n        if( [ 1, 7, 8 ].includes(i) ) {\n            boxCord.x = compDimension.x - strokeOffset - (boxSize / 2);\n        } else if( [ 2, 6 ].includes(i) ) {\n            boxCord.x = compDimension.x + ( compDimension.w / 2 ) + ( strokeOffset / 2 ) - (boxSize / 2);\n        } else if( [ 3, 4, 5 ].includes(i) ) {\n            boxCord.x = compDimension.x + compDimension.w + strokeOffset - (boxSize / 2);\n        }\n\n        if( [ 1, 2, 3 ].includes(i) ) {\n            boxCord.y = compDimension.y - strokeOffset - (boxSize / 2);\n        } else if( [ 4, 8 ].includes(i) ) {\n            boxCord.y = compDimension.y + ( compDimension.h / 2 ) + ( strokeOffset / 2 ) - (boxSize / 2);\n        } else if( [ 5, 6, 7 ].includes(i) ) {\n            boxCord.y = compDimension.y + compDimension.h + strokeOffset - (boxSize / 2);\n        }\n\n        boxCords.push( boxCord );\n    }\n\n    return boxCords;\n}\n\n/**\n * Custom Log with tag.\n * \n * @param message Any values to log.\n */\nexport const log = ( ...message: any[] ) => {\n    console.log( logTag, ...message );\n}\n","import { BoxComponent, CanvasComponent } from \"../Dtos/canvas.dtos\";\nimport { log, reversedIndexOf } from \"./common.utils\";\n\nlet cwComponents: CanvasComponent[];\nlet canvasDOM: HTMLCanvasElement;\nlet cwRender: Function;\n\nlet isDragging = false;\nlet dragCompIndex = -1;\nlet offset = {x: 0, y: 0};\n\nexport const RegisterDraggable = ( canvas: HTMLCanvasElement, components: CanvasComponent[], render: Function ) => {\n    cwComponents = components;\n    canvasDOM = canvas;\n    cwRender = render;\n\n    canvasDOM.addEventListener('mousedown', onMouseDown );\n    canvasDOM.addEventListener('mousemove', onMouseMove );\n}\n\nexport const DestroyDraggable = () => {\n    if( canvasDOM ) {\n        canvasDOM.removeEventListener('mousedown', onMouseDown );\n        canvasDOM.removeEventListener('mousemove', onMouseMove );\n    }\n}\n\nconst onMouseDown = ( event: MouseEvent ) => {\n    if( ! cwComponents.length ) return;\n\n    const revComponents = [ ...cwComponents ].reverse();\n    const canvasEvent = getCanvasEvent( event );\n    for( let comp of revComponents ) {\n        if( ! isDragging && comp.type === 'box' \n            && rectCollision(canvasEvent.x, canvasEvent.y, comp as BoxComponent )  \n        ) {\n            isDragging = true;\n            dragCompIndex = reversedIndexOf( revComponents, comp );\n            offset.x = canvasEvent.x - comp.x;\n            offset.y = canvasEvent.y - comp.y;\n\n            canvasDOM.addEventListener('mouseup', onMouseUp );\n            break;\n        }\n    }\n    triggerComponentSelect();\n}\n\nconst onMouseMove = ( event: MouseEvent ) => {\n    const canvasEvent = getCanvasEvent( event );\n    canvasDOM.style.cursor = 'default';\n    if( dragCompIndex !== -1 ) {\n        cwComponents[dragCompIndex].x = canvasEvent.x - offset.x;\n        cwComponents[dragCompIndex].y = canvasEvent.y - offset.y;\n        cwRender();\n\n        canvasDOM.style.cursor = 'move';\n    } else {\n        for( let comp of cwComponents ) {\n            if( comp.type === 'box' \n                && rectCollision(canvasEvent.x, canvasEvent.y, comp as BoxComponent ) \n            ) {\n                canvasDOM.style.cursor = 'move'; // On hover over draggable box.\n                break;\n            }\n        }\n    }\n}\n\nconst onMouseUp = () => {\n    isDragging = false;\n    dragCompIndex = -1;\n    canvasDOM.removeEventListener('mouseup', onMouseUp );\n}\n\nconst rectCollision = ( x: number, y: number, rect: BoxComponent ) => {\n    if(\n        x > rect.x\n        && y > rect.y\n        && x < ( rect.w + rect.x )\n        && y < ( rect.h + rect.y )\n    ) {\n        return true;\n    }\n    return false;\n}\n\nconst getCanvasEvent = ( event: MouseEvent ): { x: number, y: number} => {\n    const canvasRect = canvasDOM.getBoundingClientRect();\n    return { x: event.clientX - canvasRect.left, y: event.clientY - canvasRect.top }\n}\n\nconst triggerComponentSelect = () => {\n    if( canvasDOM ) {\n        const event = new CustomEvent('cwComponentSelected', { \n            detail:  { \n                index: dragCompIndex, \n                component: cwComponents[dragCompIndex] \n            } \n        });\n        canvasDOM.dispatchEvent( event );\n    }\n}","import { BorderRadius, BoxComponent, CanvasComponent, CanvasData } from \"../Dtos/canvas.dtos\";\nimport { debounce, formatBorderRadius, getSelectionBoxCords, log } from \"./common.utils\";\nimport { DestroyDraggable, RegisterDraggable } from \"./draggable.utils\";\nimport { TimeLogger } from \"./timeLogger.utils\";\n\nlet forceStopDebug = true;\nlet debug = ! forceStopDebug && process.env.NODE_ENV === 'development';\n\nlet parentDOM: HTMLDivElement;\nlet canvasDOM: HTMLCanvasElement;\nlet ctx: CanvasRenderingContext2D | null;\nlet cwMode: 'editor' | 'viewer';\n\nlet canvasDefaultData = {\n    height: 500,\n    background: '#efefef',\n    hoverColor: '#0000ff',\n    strokeColor: '#000000',\n    selectionStrokeColor: '#7f7f7f',\n    selectionLineWidth: 1,\n    lineWidth: 1,\n    fontSize: 16,\n    fontFamily: 'Arial',\n    borderRadius: 3,\n}\n\nlet canvasData: CanvasData = {}\nlet selectedIndex: number;\n\ninterface InitCanvasProps {\n    parent: HTMLDivElement,\n    canvas: HTMLCanvasElement,\n    mode?: 'editor' | 'viewer',\n    data?: CanvasData,\n}\n\n/**\n * Initialize Canvas.\n * \n * @param parent Parent DOM.\n * @param canvas Main Canvas DOM.\n * @param mode Mode of canvas workflow.\n * @param data Canvas Data. \n */\nexport const InitCanvas = (\n    { \n        parent,\n        canvas,\n        mode,\n        data,\n    } : InitCanvasProps\n) => {\n    parentDOM = parent;\n    canvasDOM = canvas;\n    cwMode = mode || 'editor';\n\n    ctx = canvas.getContext(\"2d\");\n\n    if( data ) {\n        canvasData = data;\n    }\n    \n    canvasRender();\n    if( cwMode === 'editor' && canvasData?.components?.length ) {\n        RegisterDraggable( canvasDOM, canvasData.components, canvasRender );\n    } else {\n        DestroyDraggable();\n    }\n    window.addEventListener( 'resize', debouncRender );\n    canvasDOM.addEventListener( 'cwComponentSelected', handleComponentSelect );\n}\n\n/**\n * Destroy the canvas events.\n */\nexport const DestroyCanvas = () => {\n    window.removeEventListener( 'resize', debouncRender );\n    canvasDOM.removeEventListener( 'cwComponentSelected', handleComponentSelect );\n    DestroyDraggable();\n    if( debug ) {\n        log('Canvas Destroyed');\n    }\n}\n\n/**\n * Clear Canvas.\n */\nexport const ClearCanvas = () => {\n    if( canvasDOM && ctx ) {\n        ctx.clearRect(0, 0, canvasDOM.width, canvasDOM.height);\n        if( debug ) {\n            log('Canvas Cleared!');\n        }\n    }\n}\n\nconst handleComponentSelect = ( event: CustomEvent ) => {\n    selectedIndex = event.detail.index;\n    canvasRender();\n}\n\n/**\n * Debounce the render function for performance optimization.\n */\nconst debouncRender = debounce( () => canvasRender() );\n\n/**\n * Main render function for canvas.\n */\nconst canvasRender = ( ) => {\n    if( parentDOM && canvasDOM && ctx ) {\n        let parentDim = parentDOM.getBoundingClientRect();\n        canvasDOM.width = parentDim.width;\n        canvasDOM.height = canvasData.height || canvasDefaultData.height;\n    \n        ClearCanvas();\n    \n        if( debug ) {\n            log('Rendering...');\n            log('Data:', {canvasData, canvasDefaultData} );\n            TimeLogger.start();\n        }\n        \n        setCanvasBG();\n\n        if( canvasData?.components ) {\n            canvasData.components.forEach( ( component ) => {\n                renderComponents(component);\n            } );\n        }\n\n        if( debug ) {\n            TimeLogger.stop('Render');\n            log('Render Completed');\n        }\n    }\n}\n\n/**\n * Fill background of canvas.\n */\nconst setCanvasBG = () => {\n    if( canvasDOM && ctx ) {\n        ctx.translate(0.5, 0.5); // Smoothening canvas.\n        ctx.fillStyle = canvasData.background || canvasDefaultData.background;\n        ctx.fillRect(0, 0, canvasDOM.width, canvasDOM.height);\n    }\n}\n\n/**\n * Render component in canvas.\n * @param component Canvas Component\n */\nconst renderComponents = ( component: CanvasComponent ) => {\n    processBaseComponent( component );\n    switch( component.type ) {\n        case 'box':\n            drawBoxComponent( component as BoxComponent );\n            break;\n    }\n    drawSelectionHandle( component );\n}\n\n/**\n * Process Base of component.\n * \n * @param component Canvas Component.\n */\nconst processBaseComponent = ( component: CanvasComponent ) => {\n    // Register editor mode.\n    if( cwMode === 'editor' ) {\n        \n    }\n}\n\n/**\n * Draw box selection border or indicator.\n * \n * @param component Canvas Component\n */\nconst drawSelectionHandle = ( component: CanvasComponent ) => {\n    if( \n        ctx \n        && cwMode === 'editor'\n        && selectedIndex > -1 \n        && canvasData.components?.length \n        && selectedIndex === canvasData.components.indexOf(component) \n    ) {\n        let strokeOffset = 3;\n        let dashedLine = true;\n        let compDimension = {\n            x: component.x,\n            y: component.y,\n            w: 0,\n            h: 0,\n        }\n\n        switch( component.type ) {\n            case 'box':\n                const comp = component as BoxComponent;\n                compDimension.w = comp.w;\n                compDimension.h = comp.h;\n                // dashedLine = false;\n                break;\n        }\n\n        // Draw border for selections.\n        ctx.save();\n        ctx.beginPath();\n        ctx.lineWidth = canvasData.selectionLineWidth || canvasDefaultData.selectionLineWidth;\n        if( dashedLine ) {\n            ctx.setLineDash([5, 5])\n        }\n        ctx.strokeStyle = canvasData.selectionStrokeColor || canvasDefaultData.selectionStrokeColor;\n        ctx.rect( \n            compDimension.x - strokeOffset, \n            compDimension.y - strokeOffset,\n            compDimension.w + (strokeOffset * 2),\n            compDimension.h + (strokeOffset * 2),\n        )\n        ctx.stroke();\n        ctx.restore();\n\n        // Draw border points\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = canvasData.selectionStrokeColor || canvasDefaultData.selectionStrokeColor;\n        let boxSize = 7;\n        \n        const selectionBoxes = getSelectionBoxCords( compDimension, strokeOffset, boxSize );\n        for( let box of selectionBoxes ) {\n            ctx.rect( box.x, box.y, box.w, box.h );\n        }\n\n        ctx.fill();\n        ctx.restore();\n    }\n}\n\n/**\n * Draw Box component.\n * \n * @param component Box Component\n * @returns void\n */\nconst drawBoxComponent = ( component: BoxComponent ) => {\n    if( ! ctx ) return;\n\n    const padding = 5;\n    const fontSize = component.fontSize || canvasDefaultData.fontSize;\n\n    ctx.save(); // Save the default state to restore later.\n    ctx.beginPath();\n    drawRoundedRect( ctx, component.x, component.y, component.w, component.h, component.borderRadius );\n    if( component.fillColor ) {\n        // Draw box fill\n        ctx.fillStyle = component.fillColor;\n        ctx.fill();\n    }\n\n    // Draw box stroke or border.\n    ctx.lineWidth = component.lineWidth || canvasDefaultData.lineWidth;\n    ctx.strokeStyle = component.strokeColor || component.fillColor || canvasDefaultData.strokeColor;\n    ctx.stroke();\n    ctx.clip(); // Clip inner elements inside box.\n\n    // Draw box text.\n    ctx.font = `${fontSize}px ${component.fontFamily}`;\n    ctx.fillStyle = component.textColor || canvasDefaultData.strokeColor;\n    ctx.fillText( \n        component.text, component.x + padding + ctx.lineWidth, \n        component.y + padding + fontSize + ctx.lineWidth - 5,\n    );\n    ctx.restore(); // Restore default state.\n\n}\n\nconst drawRoundedRect = ( ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, borderRadius?: BorderRadius ) => {\n    const radius = formatBorderRadius( borderRadius || canvasDefaultData.borderRadius );\n    ctx.moveTo(x + radius.tl, y);\n    ctx.lineTo(x + width - radius.tr, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\n    ctx.lineTo(x + width, y + height - radius.br);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\n    ctx.lineTo(x + radius.bl, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\n    ctx.lineTo(x, y + radius.tl);\n    ctx.quadraticCurveTo(x, y, x + radius.tl, y);\n    ctx.closePath();\n}","import React, { createRef, useEffect, useState } from 'react'\nimport { BoxComponent, CanvasData } from './Dtos/canvas.dtos';\nimport './styles.scss'\nimport { DestroyCanvas, InitCanvas } from './Utils/canvas.utils';\nimport { log } from './Utils/common.utils';\n\ninterface Props {\n    mode?: 'editor' | 'viewer';\n    defaultData?: CanvasData;\n    data?: CanvasData;\n    onDataChange?( data: CanvasData ): void;\n}\n\nconst ConvasWorkflow = ({ mode = 'editor', defaultData, data, onDataChange }: Props) => {\n\n    const [cwMode, setCwMode] = useState(mode);\n    const [cwData, setCwData] = useState<CanvasData | undefined>(data || defaultData);\n\n    const canvasRef = createRef<HTMLCanvasElement>();\n    const parentRef = createRef<HTMLDivElement>();\n\n    useEffect(() => {\n        setCwMode(mode);\n        setCwData(data);\n    }, [mode, data])\n\n    useEffect(() => {\n        if( canvasRef.current && parentRef.current ) {\n            InitCanvas({\n                parent: parentRef.current,\n                canvas: canvasRef.current,\n                mode: cwMode,\n                data: cwData,\n            });\n        }\n\n        return () => {\n            DestroyCanvas();\n        }\n    }, [canvasRef, parentRef, cwMode, cwData ])\n\n    const addRandomBox = () => {\n        const randomX = Math.floor( Math.random() * ( canvasRef.current?.width || 100 ) );\n        const randomY = Math.floor( Math.random() * ( canvasRef.current?.height || 100 ) );\n        const randomRadius = Math.floor( Math.random() * 15 );\n\n        const comp: BoxComponent = {\n            type: 'box',\n            x: randomX,\n            y: randomY,\n            w: 100,\n            h: 100,\n            fillColor: 'green',\n            text: 'Random ' + randomX + ':' + randomY,\n            borderRadius: randomRadius,\n        }\n        setCwData( { ...cwData, components: [ ...cwData?.components || [], comp ] })\n    }\n\n    const clearAll = () => {\n        setCwData( { ...cwData, components: [] } );\n    }\n\n    return (\n        <div className={`canvas-workflow`} >\n            <div className='cw-tools'>\n                <div className=''>\n                    <div>Tool Box</div>\n                </div>\n            </div>\n            <div className='cw-wrapper' ref={parentRef}>\n                <canvas ref={canvasRef}></canvas>\n            </div>\n            <div className='cw-settings'>\n                <div onClick={()=>setCwMode('viewer')}>settings</div>\n                <button onClick={addRandomBox}>Add Random Box</button>\n                <button onClick={clearAll}>Clear All</button>\n            </div>\n        </div>\n    )\n}\n\nexport default ConvasWorkflow;","import React, { useEffect, useState } from 'react'\n\nimport CanvasWorkflow from 'canvas-workflow'\nimport { CanvasData } from 'canvas-workflow/dist/Dtos/canvas.dtos'\nimport 'canvas-workflow/dist/index.css'\n\nconst App = () => {\n    const [data, setData] = useState<CanvasData>();\n\n    useEffect(() => {\n        setData({\n            components:[\n                { \n                    type: 'box',\n                    text: 'Rumesh',\n                    x: 100,\n                    y: 100,\n                    w: 150,\n                    h: 100,\n                    fillColor: 'red',\n                    strokeColor: 'green',\n                    lineWidth: 1,\n                    borderRadius: 5,\n                }\n            ]\n        })\n    }, [])\n\n    const dataChangeHandle = ( data: CanvasData ) => {\n        setData( data );\n    }\n\n    return (\n        <div>\n            <CanvasWorkflow mode='editor' data={data} onDataChange={dataChangeHandle} />\n            {/* <CanvasWorkflow mode='viewer' data={data} /> */}\n        </div>\n    )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}