{"version":3,"sources":["../../src/Constants/canvas.constants.tsx","../../src/Utils/common.utils.tsx","../../src/Utils/draggable.utils.tsx","../../src/Utils/canvas.utils.tsx","../../src/Utils/draw.utils.tsx","../../src/index.tsx","App.tsx","index.tsx"],"names":["SELECTION_RESIZE_BOX_CURSORS","IsEqualObject","object","otherObject","objKeys","Object","otherKeys","objKey","Array","i","getSelectionBoxCords","boxCords","boxCord","x","y","w","h","compDimension","SELECTION_RESIZE_BOX_SIZE","SELECTION_BOX_OFFSET","isDragging","isResizing","listenMovingCanvas","isMovingCanvas","dragCompIndex","resizeBoxIndex","offset","resizePrevCompPos","prevCursorPos","DestroyDraggable","canvasDOM","onMouseDown","cwComponents","canvasEvent","getCanvasCursorPos","tempComponents","revComponents","comp","c","rectCollision","length","arr","index","reversedIndexOf","selectionBoxes","triggerComponentSelect","onMouseMove","cursorChangeX","cursorChangeY","cwRender","cursorChangeReverseX","cursorChangeReverseY","selectionBoxActive","onMouseUp","onKeyDown","event","onKeyUp","rect","canvasRect","top","CustomEvent","detail","component","drawRoundedRect","radius","borderRadius","tl","tr","br","bl","formatBorderRadius","ctx","printAtWordWrap","fitWidth","words","text","currentLine","idx","str","lineHeight","canvasDefaultData","height","background","hoverColor","strokeColor","selectionStrokeColor","selectionLineWidth","lineWidth","fontSize","fontFamily","canvasData","InitCanvas","parent","canvas","mode","data","onDataChange","parentDOM","cwMode","handleDataChange","canvasRender","RegisterDraggable","window","handleComponentSelect","selectedIndex","debouncRender","func","timeout","args","timer","debounce","triggerDataChange","parentDim","setCanvasBG","renderComponents","padding","drawBoxComponent","box","drawSelectionHandle","useState","setCwMode","cwData","setCwData","canvasRef","createRef","parentRef","useEffect","className","React","ref","tabIndex","onClick","randomX","Math","randomY","type","title","description","fillColor","components","App","setData","console","log","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.4b884d8d.chunk.js","sourcesContent":["export const SELECTION_BOX_OFFSET = 3;\nexport const SELECTION_RESIZE_BOX_SIZE = 7;\nexport const SELECTION_RESIZE_BOX_CURSORS = [ \n    'nwse-resize', \n    'ns-resize', \n    'nesw-resize', \n    'ew-resize',\n    'nwse-resize',\n    'ns-resize',\n    'nesw-resize',\n    'ew-resize',\n];\nexport const BOX_MIN_WIDTH = 50;\nexport const BOX_MIN_HEIGHT = 50;","import { SELECTION_BOX_OFFSET, SELECTION_RESIZE_BOX_SIZE } from \"../Constants/canvas.constants\";\nimport { BorderRadius, BorderRadiusBase } from \"../Dtos/canvas.dtos\";\n\n/**\n * Log tag.\n */\nconst logTag = 'CanvasWorkflow:';\n\n/**\n * Debounce the given function.\n * \n * @param func Function.\n * @param timeout Timeout in ms.\n * @returns Function.\n */\nexport function debounce(func: Function, timeout = 300){\n    let timer: number;\n    return (...args: any[]) => {\n        window.clearTimeout(timer);\n        timer = window.setTimeout(() => { func.apply(this, args); }, timeout);\n    };\n}\n\n/**\n * Checks if two given objects are same \n * NOTE: Mainly used in persitance for identifying if two params are same\n * @param  {object} object\n * @param  {object} otherObject\n */\nexport function IsEqualObject(object: any, otherObject: any) {\n    let objKeys = Object.keys(object || {}),\n        otherKeys = Object.keys(otherObject || {});\n    \n    // Check length of object matches.\n    if (objKeys.length !== otherKeys.length) {\n        return false;\n    }\n\n    // Check index keys matches.\n    for( let objKey in objKeys ) {\n        if( objKeys[objKey] !== otherKeys[objKey] ) {\n            return false;\n        }\n    }\n\n    // Check array inside object.\n    for( let objKey of objKeys ) {\n        if( Array.isArray( object[objKey] ) ) {\n            if( object[objKey].length !== otherObject[objKey].length ) {\n                return false;\n            }\n\n            for( let i = 0; i < object[objKey].length; i++ ) {\n                if( object[objKey][i] !== otherObject[objKey][i] ) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n/**\n * Get reversed index of item in array.\n * \n * @param arr Arrays\n * @param item Item in array\n * @returns number\n */\nexport const reversedIndexOf = ( arr: any[], item: any): number => {\n    const { length } = arr;\n    const index = arr.indexOf(item);\n    if(index === -1){\n       return -1;\n    };\n    return length - index - 1;\n};\n\n/**\n * Format the border radius.\n * \n * @param borderRadius BorderRadius\n * @returns BorderRadiusBase\n */\nexport const formatBorderRadius = ( borderRadius?: BorderRadius ): BorderRadiusBase => {\n    if( typeof borderRadius !== 'number' ) {\n        return { ...{ tl: 0, tr: 0, br: 0, bl: 0 }, ...borderRadius };\n    }\n    \n    return { \n        tl: borderRadius as number, \n        tr: borderRadius as number, \n        br: borderRadius as number, \n        bl: borderRadius as number \n    };\n}\n\n/**\n * Get selection box coordinates.\n * \n * @param compDimension Component Dimension.\n * @param strokeOffset Selection stroke offset.\n * @param boxSize Box size.\n * @returns Array\n */\nexport const getSelectionBoxCords = ( compDimension: { x: number, y: number, w: number, h: number } ): { x: number, y: number, w: number, h: number }[] => {\n    let boxCords: { x: number, y: number, w: number, h: number }[] = [];\n\n    for( let i = 1; i <= 8; i++ ) {\n        let boxCord = {\n            x: 0,\n            y: 0,\n            w: SELECTION_RESIZE_BOX_SIZE,\n            h: SELECTION_RESIZE_BOX_SIZE,\n        }\n\n        if( [ 1, 7, 8 ].includes(i) ) {\n            boxCord.x = compDimension.x - SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 2, 6 ].includes(i) ) {\n            boxCord.x = compDimension.x + ( compDimension.w / 2 ) + ( SELECTION_BOX_OFFSET / 2 ) - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 3, 4, 5 ].includes(i) ) {\n            boxCord.x = compDimension.x + compDimension.w + SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        }\n\n        if( [ 1, 2, 3 ].includes(i) ) {\n            boxCord.y = compDimension.y - SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 4, 8 ].includes(i) ) {\n            boxCord.y = compDimension.y + ( compDimension.h / 2 ) + ( SELECTION_BOX_OFFSET / 2 ) - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 5, 6, 7 ].includes(i) ) {\n            boxCord.y = compDimension.y + compDimension.h + SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        }\n\n        boxCords.push( boxCord );\n    }\n\n    return boxCords;\n}\n\n/**\n * Custom Log with tag.\n * \n * @param message Any values to log.\n */\nexport const log = ( ...message: any[] ): void => {\n    console.log( logTag, ...message );\n}\n","import { BOX_MIN_HEIGHT, BOX_MIN_WIDTH, SELECTION_RESIZE_BOX_CURSORS } from \"../Constants/canvas.constants\";\nimport { BoxComponent, CanvasComponent } from \"../Dtos/canvas.dtos\";\nimport { getSelectionBoxCords, log, reversedIndexOf } from \"./common.utils\";\n\nlet cwRender: Function;\nlet canvasDOM: HTMLCanvasElement;\nlet cwComponents: CanvasComponent[];\nlet tempComponents: CanvasComponent[];\n\nlet isDragging = false;\nlet isResizing = false;\nlet listenMovingCanvas = false;\nlet isMovingCanvas = false;\n\nlet dragCompIndex = -1;\nlet resizeBoxIndex = -1;\n\nlet offset = {x: 0, y: 0};\nlet resizePrevCompPos = {x: 0, y: 0, w: 0, h: 0};\nlet prevCursorPos = {x: 0, y: 0};\n\n/**\n * Register draggable events.\n * \n * @param canvas Canvas\n * @param components Component array\n * @param render Render function of canvas.\n */\nexport const RegisterDraggable = ( canvas: HTMLCanvasElement, components: CanvasComponent[], render: Function ): void => {\n    cwComponents = components;\n    canvasDOM = canvas;\n    cwRender = render;\n\n    canvasDOM.addEventListener('mousedown', onMouseDown );\n    canvasDOM.addEventListener('mousemove', onMouseMove );\n    canvasDOM.addEventListener('keydown', onKeyDown );\n    canvasDOM.addEventListener('keyup', onKeyUp );\n}\n\n/**\n * Destroy draggable events.\n */\nexport const DestroyDraggable = (): void => {\n    if( canvasDOM ) {\n        canvasDOM.removeEventListener('mousedown', onMouseDown );\n        canvasDOM.removeEventListener('mousemove', onMouseMove );\n        canvasDOM.removeEventListener('keypress', onKeyDown );\n    }\n}\n\n/**\n * Mouse down event.\n * \n * @param event MouseEvent\n */\nconst onMouseDown = ( event: MouseEvent ): void => {\n    if( ! cwComponents.length ) return;\n\n    const canvasEvent = getCanvasCursorPos( event );\n\n    // Move canvas\n    if( listenMovingCanvas && ! isMovingCanvas ) {\n        isMovingCanvas = true;\n        prevCursorPos = { ...canvasEvent };\n        tempComponents = cwComponents.map(object => ({ ...object }));\n        canvasDOM.style.cursor = 'grabbing';\n        canvasDOM.addEventListener('mouseup', onMouseUp );\n        return;\n    }\n\n    const revComponents = [ ...cwComponents ].reverse();\n    // Loop each components for hit.\n    for( let comp of revComponents ) {\n        let compDimension = {\n            x: comp.x,\n            y: comp.y,\n            w: 0,\n            h: 0,\n        }\n\n        switch( comp.type ) {\n            case 'box':\n                const c = comp as BoxComponent;\n                compDimension.w = c.w;\n                compDimension.h = c.h;\n                break;\n        }\n\n        if( ! isDragging && rectCollision(canvasEvent.x, canvasEvent.y, compDimension ) ) {\n            isDragging = true;\n            dragCompIndex = reversedIndexOf( revComponents, comp );\n            offset.x = canvasEvent.x - comp.x;\n            offset.y = canvasEvent.y - comp.y;\n\n            canvasDOM.addEventListener('mouseup', onMouseUp );\n            break;\n        }\n\n        if( ! isResizing && dragCompIndex !== -1 ) {\n            const selectionBoxes = getSelectionBoxCords( compDimension );\n            // Loop each selection boxes for hit.\n            selectionBoxes.every( ( box, index ) => {\n                if( rectCollision(canvasEvent.x, canvasEvent.y, box ) ) {\n                    isResizing = true;\n                    prevCursorPos = { ...canvasEvent };\n                    resizePrevCompPos = { ...compDimension };\n                    resizeBoxIndex = index;\n\n                    canvasDOM.addEventListener('mouseup', onMouseUp );\n                    return false;\n                }\n\n                return true;\n            } )\n            // Break loop for components if resizing.\n            if( isResizing ) {\n                break;\n            }\n        }\n    }\n\n    if( ! isDragging && ! isResizing ) {\n        dragCompIndex = -1;\n        resizeBoxIndex = -1;\n    }\n    triggerComponentSelect();\n}\n\n/**\n * Mouse move event.\n * \n * @param event MouseEvent\n */\nconst onMouseMove = ( event: MouseEvent ): void => {\n    const canvasEvent = getCanvasCursorPos( event );\n\n    if( listenMovingCanvas ) {\n        if( isMovingCanvas ) {\n\n            // Move canvas.\n            let cursorChangeX = prevCursorPos.x - canvasEvent.x;\n            let cursorChangeY = prevCursorPos.y - canvasEvent.y;\n\n            for( let index = 0; index < cwComponents.length; index++ ) {\n                cwComponents[index].x = tempComponents[index].x - cursorChangeX;\n                cwComponents[index].y = tempComponents[index].y - cursorChangeY;\n            }\n            cwRender();\n        }\n    } else if( isDragging && ! isResizing && dragCompIndex !== -1 ) {\n\n        // Drag component.\n        cwComponents[dragCompIndex].x = canvasEvent.x - offset.x;\n        cwComponents[dragCompIndex].y = canvasEvent.y - offset.y;\n        cwRender();\n    } else if( isResizing && dragCompIndex !== -1 ) {\n\n        // Resize box draw.\n        let cursorChangeX = prevCursorPos.x - canvasEvent.x;\n        let cursorChangeY = prevCursorPos.y - canvasEvent.y;\n\n        let cursorChangeReverseX = canvasEvent.x - prevCursorPos.x;\n        let cursorChangeReverseY = canvasEvent.y - prevCursorPos.y;\n\n        if( [ 0, 6, 7 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].x = resizePrevCompPos.x - cursorChangeX;\n            cwComponents[dragCompIndex].w = resizePrevCompPos.w + cursorChangeX;\n        }\n        if( [ 0, 1, 2 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].y = resizePrevCompPos.y - cursorChangeY;\n            cwComponents[dragCompIndex].h = resizePrevCompPos.h + cursorChangeY;\n        }\n        if( [ 2, 3, 4 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].w = resizePrevCompPos.w + cursorChangeReverseX;\n        }\n        if( [ 4, 5, 6 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].h = resizePrevCompPos.h + cursorChangeReverseY;\n        }\n\n        // Maintain minimum weidth and height.\n        if( cwComponents[dragCompIndex].w <= BOX_MIN_WIDTH ) {\n            cwComponents[dragCompIndex].w = BOX_MIN_WIDTH;\n        }\n        if( cwComponents[dragCompIndex].h <= BOX_MIN_HEIGHT ) {\n            cwComponents[dragCompIndex].h = BOX_MIN_HEIGHT;\n        }\n\n        cwRender();\n    } else {\n        cwComponents.every( ( comp, index ) => {\n            let compDimension = {\n                x: comp.x,\n                y: comp.y,\n                w: 0,\n                h: 0,\n            }\n    \n            switch( comp.type ) {\n                case 'box':\n                    const c = comp as BoxComponent;\n                    compDimension.w = c.w;\n                    compDimension.h = c.h;\n                    break;\n            }\n\n            if( rectCollision(canvasEvent.x, canvasEvent.y, compDimension ) ) {\n                canvasDOM.style.cursor = 'move'; // On hover over draggable box.\n                return false;\n            }\n\n            canvasDOM.style.cursor = 'default';\n\n            let selectionBoxActive = false;\n            if( index === dragCompIndex ) {\n                const selectionBoxes = getSelectionBoxCords( compDimension );\n                selectionBoxes.every( ( box, index ) => {\n                    if( rectCollision(canvasEvent.x, canvasEvent.y, box ) ) {\n                        canvasDOM.style.cursor = SELECTION_RESIZE_BOX_CURSORS[index] || 'move';\n                        selectionBoxActive = true;\n                        return false;\n                    }\n                    return true;\n                } )\n            }\n\n            if( selectionBoxActive ) return false;\n            return true;\n        } );\n    }\n}\n\n/**\n * Mouse up event.\n */\nconst onMouseUp = (): void => {\n    if ( isMovingCanvas ) {\n        canvasDOM.style.cursor = 'grab';\n    }\n    isDragging = false;\n    isResizing = false;\n    isMovingCanvas = false;\n    tempComponents = [];\n    canvasDOM.removeEventListener('mouseup', onMouseUp );\n}\n\n/**\n * Key down event.\n * \n * @param event KeyboardEvent\n */\nconst onKeyDown = ( event: KeyboardEvent ): void => {\n    event.preventDefault();\n    if( event.key === ' ' && ! listenMovingCanvas ) {\n        canvasDOM.style.cursor = 'grab'\n        listenMovingCanvas = true;\n    } \n}\n\n/**\n * Key up event.\n * \n * @param event KeyboardEvent\n */\nconst onKeyUp = ( event: KeyboardEvent ): void => {\n    if( event.key === ' ' ) {\n        listenMovingCanvas = false;\n        isMovingCanvas = false;\n        tempComponents = [];\n        canvasDOM.style.cursor = 'default'\n    }\n}\n\n/**\n * Rectangular collision detection.\n * \n * @param x Cursor X.\n * @param y Cursor Y\n * @param rect Rectangle coords.\n * @returns boolean\n */\nconst rectCollision = ( x: number, y: number, rect: { x: number, y: number, w: number, h: number } ): boolean => {\n    if(\n        x > rect.x\n        && y > rect.y\n        && x < ( rect.w + rect.x )\n        && y < ( rect.h + rect.y )\n    ) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Get cursor position in canvas.\n * \n * @param event MouseEvent\n * @returns object\n */\nconst getCanvasCursorPos = ( event: MouseEvent ): { x: number, y: number} => {\n    const canvasRect = canvasDOM.getBoundingClientRect();\n    return { x: event.clientX - canvasRect.left, y: event.clientY - canvasRect.top }\n}\n\n/**\n * Trigger component select event. 'cwComponentSelected'\n */\nconst triggerComponentSelect = (): void => {\n    if( canvasDOM ) {\n        const event = new CustomEvent('cwComponentSelected', { \n            detail:  { \n                index: dragCompIndex, \n                component: cwComponents[dragCompIndex] \n            } \n        });\n        canvasDOM.dispatchEvent( event );\n    }\n}","import { BoxComponent, CanvasComponent, CanvasData } from \"../Dtos/canvas.dtos\";\nimport { debounce, log } from \"./common.utils\";\nimport { DestroyDraggable, RegisterDraggable } from \"./draggable.utils\";\nimport { TimeLogger } from \"./timeLogger.utils\";\nimport { drawBoxComponent, drawSelectionHandle } from './draw.utils';\n\nlet forceStopDebug = true;\nlet debug = ! forceStopDebug && process.env.NODE_ENV === 'development';\n\nlet parentDOM: HTMLDivElement;\nlet canvasDOM: HTMLCanvasElement;\nlet ctx: CanvasRenderingContext2D | null;\nlet handleDataChange: ( data: CanvasData ) => void;\nlet cwMode: 'editor' | 'viewer';\n\nlet canvasDefaultData = {\n    height: 500,\n    background: '#f5f5f5',\n    hoverColor: '#0000ff',\n    strokeColor: '#000000',\n    selectionStrokeColor: '#7f7f7f',\n    selectionLineWidth: 1,\n    lineWidth: 1,\n    fontSize: 16,\n    fontFamily: 'Arial',\n    borderRadius: 3,\n}\n\nlet canvasData: CanvasData = {}\nlet selectedIndex: number;\n\ninterface InitCanvasProps {\n    parent: HTMLDivElement,\n    canvas: HTMLCanvasElement,\n    mode?: 'editor' | 'viewer',\n    data?: CanvasData,\n    onDataChange?: ( data: CanvasData ) => void\n}\n\n/**\n * Initialize Canvas.\n * \n * @param parent Parent DOM.\n * @param canvas Main Canvas DOM.\n * @param mode Mode of canvas workflow.\n * @param data Canvas Data. \n */\nexport const InitCanvas = (\n    { \n        parent,\n        canvas,\n        mode,\n        data,\n        onDataChange,\n    } : InitCanvasProps\n) => {\n    parentDOM = parent;\n    canvasDOM = canvas;\n    cwMode = mode || 'editor';\n    ctx = canvas.getContext(\"2d\");\n    if( onDataChange ) {\n        handleDataChange = onDataChange;\n    }\n\n    if( data ) {\n        canvasData = data;\n    }\n    \n    canvasRender( false );\n    if( cwMode === 'editor' && canvasData?.components?.length ) {\n        RegisterDraggable( canvasDOM, canvasData.components, canvasRender );\n    } else {\n        DestroyDraggable();\n    }\n    window.addEventListener( 'resize', debouncRender );\n    canvasDOM.addEventListener( 'cwComponentSelected', handleComponentSelect );\n}\n\n/**\n * Destroy the canvas events.\n */\nexport const DestroyCanvas = () => {\n    window.removeEventListener( 'resize', debouncRender );\n    canvasDOM.removeEventListener( 'cwComponentSelected', handleComponentSelect );\n    DestroyDraggable();\n    if( debug ) {\n        log('Canvas Destroyed');\n    }\n}\n\n/**\n * Clear Canvas.\n */\nexport const ClearCanvas = () => {\n    if( canvasDOM && ctx ) {\n        ctx.clearRect(0, 0, canvasDOM.width, canvasDOM.height);\n        if( debug ) {\n            log('Canvas Cleared!');\n        }\n    }\n}\n\nconst handleComponentSelect = ( event: CustomEvent ) => {\n    if( selectedIndex !== event.detail.index ) {\n        selectedIndex = event.detail.index;\n        canvasRender( false );\n    }\n}\n\n/**\n * Debounce the render function for performance optimization.\n */\nconst debouncRender = debounce( () => canvasRender() );\n\n/**\n * Main render function for canvas.\n */\nconst canvasRender = ( triggerDataChange = true ) => {\n    if( parentDOM && canvasDOM && ctx ) {\n        let parentDim = parentDOM.getBoundingClientRect();\n        canvasDOM.width = parentDim.width;\n        canvasDOM.height = canvasData.height || canvasDefaultData.height;\n    \n        ClearCanvas();\n    \n        if( debug ) {\n            log('Rendering...');\n            log('Data:', {canvasData, canvasDefaultData} );\n            TimeLogger.start();\n        }\n        \n        setCanvasBG();\n\n        if( canvasData?.components ) {\n            canvasData.components.forEach( ( component ) => {\n                renderComponents(component);\n            } );\n        }\n\n        if( debug ) {\n            TimeLogger.stop('Render');\n            log('Render Completed');\n        }\n\n        if( triggerDataChange ) {\n            handleDataChange( canvasData );\n        }\n    }\n}\n\n/**\n * Fill background of canvas.\n */\nconst setCanvasBG = () => {\n    if( canvasDOM && ctx ) {\n        ctx.translate(0.5, 0.5); // Smoothening canvas.\n        ctx.fillStyle = canvasData.background || canvasDefaultData.background;\n        ctx.fillRect(0, 0, canvasDOM.width, canvasDOM.height);\n    }\n}\n\n/**\n * Render component in canvas.\n * @param component Canvas Component\n */\nconst renderComponents = ( component: CanvasComponent ) => {\n    processBaseComponent( component );\n    switch( component.type ) {\n        case 'box':\n            drawBoxComponent( component as BoxComponent, canvasDefaultData, ctx );\n            break;\n    }\n    drawSelectionHandle( component, canvasData, selectedIndex, canvasDefaultData, cwMode, ctx );\n}\n\n/**\n * Process Base of component.\n * \n * @param component Canvas Component.\n */\nconst processBaseComponent = ( component: CanvasComponent ) => {\n    // Register editor mode.\n    if( cwMode === 'editor' ) {\n        \n    }\n}","import { SELECTION_BOX_OFFSET } from \"../Constants/canvas.constants\";\nimport { BorderRadius, BoxComponent, CanvasComponent, CanvasData } from \"../Dtos/canvas.dtos\";\nimport { formatBorderRadius, getSelectionBoxCords, log } from \"./common.utils\";\n\n\n/**\n * Draw Box component.\n * \n * @param component Box Component\n * @returns void\n */\nexport const drawBoxComponent = ( component: BoxComponent, canvasDefaultData: any,  ctx?: CanvasRenderingContext2D | null ) => {\n    if( ! ctx ) return;\n\n    const padding = 5;\n    const fontSize = component.fontSize || canvasDefaultData.fontSize;\n\n    ctx.save(); // Save the default state to restore later.\n    ctx.beginPath();\n    drawRoundedRect( ctx, component.x, component.y, component.w, component.h, component.borderRadius || canvasDefaultData.borderRadius );\n    if( component.fillColor ) {\n        // Draw box fill\n        ctx.fillStyle = component.fillColor;\n        ctx.fill();\n    }\n\n    // Draw box stroke or border.\n    ctx.lineWidth = component.lineWidth || canvasDefaultData.lineWidth;\n    ctx.strokeStyle = component.strokeColor || component.fillColor || canvasDefaultData.strokeColor;\n    ctx.stroke();\n    ctx.clip(); // Clip inner elements inside box.\n\n    // Draw box text.\n    ctx.font = `${fontSize}px ${component.fontFamily}`;\n    ctx.fillStyle = component.textColor || canvasDefaultData.strokeColor;\n    ctx.fillText( \n        component.title, \n        component.x + padding + ctx.lineWidth, \n        component.y + padding + fontSize + ctx.lineWidth - 5,\n    );\n    \n    if( component.description ) {\n        printAtWordWrap( \n            ctx,\n            component.description,\n            component.x + padding + ctx.lineWidth,\n            component.y + (padding * 2) + (fontSize * 2) + ctx.lineWidth - 5,\n            fontSize,\n            component.w - (padding * 2) - ctx.lineWidth,\n        );\n    }\n    ctx.restore(); // Restore default state.\n}\n\n\nexport const drawRoundedRect = ( ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, borderRadius?: BorderRadius ) => {\n    const radius = formatBorderRadius( borderRadius );\n    ctx.moveTo(x + radius.tl, y);\n    ctx.lineTo(x + width - radius.tr, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\n    ctx.lineTo(x + width, y + height - radius.br);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\n    ctx.lineTo(x + radius.bl, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\n    ctx.lineTo(x, y + radius.tl);\n    ctx.quadraticCurveTo(x, y, x + radius.tl, y);\n    ctx.closePath();\n}\n\n/**\n * Draw box selection border or indicator.\n * \n * @param component Canvas Component\n */\nexport const drawSelectionHandle = ( component: CanvasComponent, canvasData: CanvasData, selectedIndex: number, canvasDefaultData: any, cwMode: 'editor' | 'viewer', ctx?: CanvasRenderingContext2D | null ) => {\n    if( \n        ctx \n        && cwMode === 'editor'\n        && selectedIndex > -1 \n        && canvasData.components?.length \n        && selectedIndex === canvasData.components.indexOf(component) \n    ) {\n        let dashedLine = true;\n        let compDimension = {\n            x: component.x,\n            y: component.y,\n            w: 0,\n            h: 0,\n        }\n\n        switch( component.type ) {\n            case 'box':\n                const comp = component as BoxComponent;\n                compDimension.w = comp.w;\n                compDimension.h = comp.h;\n                // dashedLine = false;\n                break;\n        }\n\n        // Draw border for selections.\n        ctx.save();\n        ctx.beginPath();\n        ctx.lineWidth = canvasData.selectionLineWidth || canvasDefaultData.selectionLineWidth;\n        if( dashedLine ) {\n            ctx.setLineDash([5, 5])\n        }\n        ctx.strokeStyle = canvasData.selectionStrokeColor || canvasDefaultData.selectionStrokeColor;\n        ctx.rect( \n            compDimension.x - SELECTION_BOX_OFFSET, \n            compDimension.y - SELECTION_BOX_OFFSET,\n            compDimension.w + (SELECTION_BOX_OFFSET * 2),\n            compDimension.h + (SELECTION_BOX_OFFSET * 2),\n        )\n        ctx.stroke();\n        ctx.restore();\n\n        // Draw border points\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = canvasData.selectionStrokeColor || canvasDefaultData.selectionStrokeColor;\n        \n        const selectionBoxes = getSelectionBoxCords( compDimension );\n        for( let box of selectionBoxes ) {\n            ctx.rect( box.x, box.y, box.w, box.h );\n        }\n\n        ctx.fill();\n        ctx.restore();\n    }\n}\n\nexport const printAtWordWrap = ( ctx: CanvasRenderingContext2D , text: string, x: number, y: number, lineHeight: number, fitWidth?: number) => {\n    fitWidth = fitWidth || 0;\n    \n    if (fitWidth <= 0)\n    {\n        ctx.fillText( text, x, y );\n        return;\n    }\n    var words = text.split(' ');\n    var currentLine = 0;\n    var idx = 1;\n    while (words.length > 0 && idx <= words.length)\n    {\n        var str = words.slice(0,idx).join(' ');\n        var w = ctx.measureText(str).width;\n        if ( w > fitWidth )\n        {\n            if (idx==1)\n            {\n                idx=2;\n            }\n            ctx.fillText( words.slice(0,idx-1).join(' '), x, y + (lineHeight * currentLine) );\n            currentLine++;\n            words = words.splice(idx-1);\n            idx = 1;\n        }\n        else\n        {idx++;}\n    }\n    if  (idx > 0)\n        ctx.fillText( words.join(' '), x, y + (lineHeight * currentLine) );\n}","import React, { createRef, useEffect, useState } from 'react'\nimport { BoxComponent, CanvasData } from './Dtos/canvas.dtos';\nimport { DestroyCanvas, InitCanvas } from './Utils/canvas.utils';\nimport { IsEqualObject, log } from './Utils/common.utils';\nimport './styles.scss'\n\ninterface Props {\n    mode?: 'editor' | 'viewer';\n    data?: CanvasData;\n    onDataChange?( data: CanvasData ): void;\n}\n\nconst ConvasWorkflow = ({ mode = 'editor', data = {}, onDataChange }: Props) => {\n\n    const [cwMode, setCwMode] = useState(mode);\n    const [cwData, setCwData] = useState<CanvasData>(data);\n\n    const canvasRef = createRef<HTMLCanvasElement>();\n    const parentRef = createRef<HTMLDivElement>();\n\n    useEffect(() => {\n        if( cwMode !== mode ) {\n            setCwMode(mode);\n        }\n        if( ! IsEqualObject( data, cwData ) ) {\n            setCwData(data);\n        }\n    }, [mode, data]);\n\n    useEffect(() => {\n        if( ! IsEqualObject( data, cwData ) && typeof onDataChange === 'function' ) {\n            onDataChange( cwData );\n        }\n    }, [cwData])\n\n    useEffect(() => {\n        if( canvasRef.current && parentRef.current ) {\n            InitCanvas({\n                parent: parentRef.current,\n                canvas: canvasRef.current,\n                mode: cwMode,\n                data: cwData,\n                onDataChange,\n            });\n        }\n\n        return () => {\n            DestroyCanvas();\n        }\n    }, [canvasRef, parentRef, cwMode, cwData ])\n\n    const addRandomBox = () => {\n        const randomX = Math.floor( Math.random() * ( canvasRef.current?.width || 100 ) );\n        const randomY = Math.floor( Math.random() * ( canvasRef.current?.height || 100 ) );\n        // const randomRadius = Math.floor( Math.random() * 15 );\n\n        const comp: BoxComponent = {\n            type: 'box',\n            title: 'Random',\n            description: 'Random ' + randomX + ':' + randomY,\n            x: randomX,\n            y: randomY,\n            w: 150,\n            h: 100,\n            fillColor: '#ffffff',\n            strokeColor: '#ccc',\n            borderRadius: 2,\n        }\n        setCwData( { ...cwData, components: [ ...cwData?.components || [], comp ] });\n    }\n\n    const clearAll = () => {\n        setCwData( { ...cwData, components: [] } );\n    }\n\n    return (\n        <div className={`canvas-workflow`} >\n            <div className='cw-tools'>\n                <div className=''>\n                    <div>Tool Box</div>\n                </div>\n            </div>\n            <div className='cw-wrapper' ref={parentRef}>\n                <canvas ref={canvasRef} tabIndex={1}></canvas>\n            </div>\n            <div className='cw-settings'>\n                <div onClick={()=>setCwMode('viewer')}>settings</div>\n                <button onClick={addRandomBox}>Add Random Box</button>\n                <button onClick={clearAll}>Clear All</button>\n            </div>\n        </div>\n    )\n}\n\nexport default ConvasWorkflow;","import React, { useState } from 'react'\n\nimport CanvasWorkflow from 'canvas-workflow'\nimport { CanvasData } from 'canvas-workflow/dist/Dtos/canvas.dtos'\nimport 'canvas-workflow/dist/index.css'\n\nconst App = () => {\n    const [ data, setData ] = useState<CanvasData>({\n        components:[\n            { \n                type: 'box',\n                title: 'Rumesh',\n                description: 'Hello my name is rumesh udash',\n                x: 100,\n                y: 100,\n                w: 150,\n                h: 100,\n                fillColor: 'red',\n                strokeColor: 'green',\n                lineWidth: 1,\n                borderRadius: 5,\n            }\n        ]\n    });\n\n    const dataChangeHandle = ( data: CanvasData ) => {\n        setData( data );\n        console.log( data );\n    }\n\n    return (\n        <div>\n            <CanvasWorkflow mode='editor' data={data} onDataChange={dataChangeHandle} />\n            {/* <CanvasWorkflow mode='viewer' data={data} /> */}\n        </div>\n    )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}