{"version":3,"sources":["../../src/Constants/canvas.constants.tsx","../../src/Utils/common.utils.tsx","../../src/Utils/draggable.utils.tsx","../../src/Utils/canvas.utils.tsx","../../src/Utils/draw.utils.tsx","../../src/index.tsx","App.tsx","index.tsx"],"names":["SELECTION_RESIZE_BOX_CURSORS","getSelectionBoxCords","boxCords","i","boxCord","x","y","w","h","compDimension","SELECTION_RESIZE_BOX_SIZE","SELECTION_BOX_OFFSET","isDragging","isResizing","dragCompIndex","resizeBoxIndex","offset","resizePrevCompPos","resizeCursorPos","DestroyDraggable","canvasDOM","onMouseDown","cwComponents","revComponents","canvasEvent","getCanvasEvent","comp","c","rectCollision","length","arr","index","reversedIndexOf","selectionBoxes","triggerComponentSelect","onMouseMove","cwRender","cursorChangeX","cursorChangeY","cursorChangeReverseX","cursorChangeReverseY","selectionBoxActive","onMouseUp","rect","canvasRect","event","top","CustomEvent","detail","component","drawRoundedRect","radius","borderRadius","tl","tr","br","bl","formatBorderRadius","ctx","printAtWordWrap","fitWidth","words","text","currentLine","idx","str","lineHeight","canvasDefaultData","height","background","hoverColor","strokeColor","selectionStrokeColor","selectionLineWidth","lineWidth","fontSize","fontFamily","canvasData","InitCanvas","parent","canvas","mode","data","parentDOM","cwMode","canvasRender","RegisterDraggable","window","handleComponentSelect","selectedIndex","debouncRender","func","timeout","args","timer","debounce","parentDim","setCanvasBG","renderComponents","padding","drawBoxComponent","box","drawSelectionHandle","defaultData","useState","setCwMode","cwData","setCwData","canvasRef","createRef","parentRef","useEffect","className","React","ref","onClick","randomX","Math","randomY","type","title","description","fillColor","components","App","setData","onDataChange","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.1abb467e.chunk.js","sourcesContent":["export const SELECTION_BOX_OFFSET = 3;\nexport const SELECTION_RESIZE_BOX_SIZE = 7;\nexport const SELECTION_RESIZE_BOX_CURSORS = [ \n    'nwse-resize', \n    'ns-resize', \n    'nesw-resize', \n    'ew-resize',\n    'nwse-resize',\n    'ns-resize',\n    'nesw-resize',\n    'ew-resize',\n];\nexport const BOX_MIN_WIDTH = 50;\nexport const BOX_MIN_HEIGHT = 50;","import { SELECTION_BOX_OFFSET, SELECTION_RESIZE_BOX_SIZE } from \"../Constants/canvas.constants\";\nimport { BorderRadius, BorderRadiusBase } from \"../Dtos/canvas.dtos\";\n\n/**\n * Log tag.\n */\nconst logTag = 'CanvasWorkflow:';\n\n/**\n * Debounce the given function.\n * \n * @param func Function.\n * @param timeout Timeout in ms.\n * @returns Function.\n */\nexport function debounce(func: Function, timeout = 300){\n    let timer: number;\n    return (...args: any[]) => {\n        window.clearTimeout(timer);\n        timer = window.setTimeout(() => { func.apply(this, args); }, timeout);\n    };\n}\n\n/**\n * Get reversed index of item in array.\n * \n * @param arr Arrays\n * @param item Item in array\n * @returns number\n */\nexport const reversedIndexOf = ( arr: any[], item: any): number => {\n    const { length } = arr;\n    const index = arr.indexOf(item);\n    if(index === -1){\n       return -1;\n    };\n    return length - index - 1;\n};\n\n/**\n * Format the border radius.\n * \n * @param borderRadius BorderRadius\n * @returns BorderRadiusBase\n */\nexport const formatBorderRadius = ( borderRadius?: BorderRadius ): BorderRadiusBase => {\n    if( typeof borderRadius !== 'number' ) {\n        return { ...{ tl: 0, tr: 0, br: 0, bl: 0 }, ...borderRadius };\n    }\n    \n    return { \n        tl: borderRadius as number, \n        tr: borderRadius as number, \n        br: borderRadius as number, \n        bl: borderRadius as number \n    };\n}\n\n/**\n * Get selection box coordinates.\n * \n * @param compDimension Component Dimension.\n * @param strokeOffset Selection stroke offset.\n * @param boxSize Box size.\n * @returns Array\n */\nexport const getSelectionBoxCords = ( compDimension: { x: number, y: number, w: number, h: number } ): { x: number, y: number, w: number, h: number }[] => {\n    let boxCords: { x: number, y: number, w: number, h: number }[] = [];\n\n    for( let i = 1; i <= 8; i++ ) {\n        let boxCord = {\n            x: 0,\n            y: 0,\n            w: SELECTION_RESIZE_BOX_SIZE,\n            h: SELECTION_RESIZE_BOX_SIZE,\n        }\n\n        if( [ 1, 7, 8 ].includes(i) ) {\n            boxCord.x = compDimension.x - SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 2, 6 ].includes(i) ) {\n            boxCord.x = compDimension.x + ( compDimension.w / 2 ) + ( SELECTION_BOX_OFFSET / 2 ) - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 3, 4, 5 ].includes(i) ) {\n            boxCord.x = compDimension.x + compDimension.w + SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        }\n\n        if( [ 1, 2, 3 ].includes(i) ) {\n            boxCord.y = compDimension.y - SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 4, 8 ].includes(i) ) {\n            boxCord.y = compDimension.y + ( compDimension.h / 2 ) + ( SELECTION_BOX_OFFSET / 2 ) - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 5, 6, 7 ].includes(i) ) {\n            boxCord.y = compDimension.y + compDimension.h + SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        }\n\n        boxCords.push( boxCord );\n    }\n\n    return boxCords;\n}\n\n/**\n * Custom Log with tag.\n * \n * @param message Any values to log.\n */\nexport const log = ( ...message: any[] ): void => {\n    console.log( logTag, ...message );\n}\n","import { BOX_MIN_HEIGHT, BOX_MIN_WIDTH, SELECTION_RESIZE_BOX_CURSORS } from \"../Constants/canvas.constants\";\nimport { BoxComponent, CanvasComponent } from \"../Dtos/canvas.dtos\";\nimport { getSelectionBoxCords, log, reversedIndexOf } from \"./common.utils\";\n\nlet cwComponents: CanvasComponent[];\nlet canvasDOM: HTMLCanvasElement;\nlet cwRender: Function;\n\nlet isDragging = false;\nlet isResizing = false;\nlet dragCompIndex = -1;\nlet resizeBoxIndex = -1;\nlet offset = {x: 0, y: 0};\nlet resizePrevCompPos = {x: 0, y: 0, w: 0, h: 0};\nlet resizeCursorPos = {x: 0, y: 0};\n\nexport const RegisterDraggable = ( canvas: HTMLCanvasElement, components: CanvasComponent[], render: Function ): void => {\n    cwComponents = components;\n    canvasDOM = canvas;\n    cwRender = render;\n\n    canvasDOM.addEventListener('mousedown', onMouseDown );\n    canvasDOM.addEventListener('mousemove', onMouseMove );\n}\n\nexport const DestroyDraggable = (): void => {\n    if( canvasDOM ) {\n        canvasDOM.removeEventListener('mousedown', onMouseDown );\n        canvasDOM.removeEventListener('mousemove', onMouseMove );\n    }\n}\n\nconst onMouseDown = ( event: MouseEvent ): void => {\n    if( ! cwComponents.length ) return;\n\n    const revComponents = [ ...cwComponents ].reverse();\n    const canvasEvent = getCanvasEvent( event );\n    // Loop each components for hit.\n    for( let comp of revComponents ) {\n        let compDimension = {\n            x: comp.x,\n            y: comp.y,\n            w: 0,\n            h: 0,\n        }\n\n        switch( comp.type ) {\n            case 'box':\n                const c = comp as BoxComponent;\n                compDimension.w = c.w;\n                compDimension.h = c.h;\n                break;\n        }\n\n        if( ! isDragging && rectCollision(canvasEvent.x, canvasEvent.y, compDimension ) ) {\n            isDragging = true;\n            dragCompIndex = reversedIndexOf( revComponents, comp );\n            offset.x = canvasEvent.x - comp.x;\n            offset.y = canvasEvent.y - comp.y;\n\n            canvasDOM.addEventListener('mouseup', onMouseUp );\n            break;\n        }\n\n        if( ! isResizing && dragCompIndex !== -1 ) {\n            const selectionBoxes = getSelectionBoxCords( compDimension );\n            // Loop each selection boxes for hit.\n            selectionBoxes.every( ( box, index ) => {\n                if( rectCollision(canvasEvent.x, canvasEvent.y, box ) ) {\n                    isResizing = true;\n                    resizeCursorPos = { ...canvasEvent };\n                    resizePrevCompPos = { ...compDimension };\n                    resizeBoxIndex = index;\n\n                    canvasDOM.addEventListener('mouseup', onMouseUp );\n                    return false;\n                }\n\n                return true;\n            } )\n            // Break loop for components if resizing.\n            if( isResizing ) {\n                break;\n            }\n        }\n    }\n\n    if( ! isDragging && ! isResizing ) {\n        dragCompIndex = -1;\n        resizeBoxIndex = -1;\n    }\n    triggerComponentSelect();\n}\n\nconst onMouseMove = ( event: MouseEvent ): void => {\n    const canvasEvent = getCanvasEvent( event );\n    if( isDragging && ! isResizing && dragCompIndex !== -1 ) {\n\n        cwComponents[dragCompIndex].x = canvasEvent.x - offset.x;\n        cwComponents[dragCompIndex].y = canvasEvent.y - offset.y;\n        cwRender();\n    } else if( isResizing && dragCompIndex !== -1 ) {\n\n        // Resize box draw.\n        let cursorChangeX = resizeCursorPos.x - canvasEvent.x;\n        let cursorChangeY = resizeCursorPos.y - canvasEvent.y;\n\n        let cursorChangeReverseX = canvasEvent.x - resizeCursorPos.x;\n        let cursorChangeReverseY = canvasEvent.y - resizeCursorPos.y;\n\n        if( [ 0, 6, 7 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].x = resizePrevCompPos.x - cursorChangeX;\n            cwComponents[dragCompIndex].w = resizePrevCompPos.w + cursorChangeX;\n        }\n\n        if( [ 0, 1, 2 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].y = resizePrevCompPos.y - cursorChangeY;\n            cwComponents[dragCompIndex].h = resizePrevCompPos.h + cursorChangeY;\n        }\n\n        if( [ 2, 3, 4 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].w = resizePrevCompPos.w + cursorChangeReverseX;\n        }\n\n        if( [ 4, 5, 6 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].h = resizePrevCompPos.h + cursorChangeReverseY;\n        }\n\n        // Maintain minimum weidth and height.\n        if( cwComponents[dragCompIndex].w <= BOX_MIN_WIDTH ) {\n            cwComponents[dragCompIndex].w = BOX_MIN_WIDTH;\n        }\n        if( cwComponents[dragCompIndex].h <= BOX_MIN_HEIGHT ) {\n            cwComponents[dragCompIndex].h = BOX_MIN_HEIGHT;\n        }\n\n        cwRender();\n    } else {\n        cwComponents.every( ( comp, index ) => {\n            let compDimension = {\n                x: comp.x,\n                y: comp.y,\n                w: 0,\n                h: 0,\n            }\n    \n            switch( comp.type ) {\n                case 'box':\n                    const c = comp as BoxComponent;\n                    compDimension.w = c.w;\n                    compDimension.h = c.h;\n                    break;\n            }\n\n            if( rectCollision(canvasEvent.x, canvasEvent.y, compDimension ) ) {\n                canvasDOM.style.cursor = 'move'; // On hover over draggable box.\n                return false;\n            }\n\n            canvasDOM.style.cursor = 'default';\n\n            let selectionBoxActive = false;\n            if( index === dragCompIndex ) {\n                const selectionBoxes = getSelectionBoxCords( compDimension );\n                selectionBoxes.every( ( box, index ) => {\n                    if( rectCollision(canvasEvent.x, canvasEvent.y, box ) ) {\n                        canvasDOM.style.cursor = SELECTION_RESIZE_BOX_CURSORS[index] || 'move';\n                        selectionBoxActive = true;\n                        return false;\n                    }\n                    return true;\n                } )\n            }\n\n            if( selectionBoxActive ) return false;\n            return true;\n        } );\n    }\n}\n\nconst onMouseUp = (): void => {\n    isDragging = false;\n    isResizing = false;\n    canvasDOM.removeEventListener('mouseup', onMouseUp );\n}\n\nconst rectCollision = ( x: number, y: number, rect: { x: number, y: number, w: number, h: number } ): boolean => {\n    if(\n        x > rect.x\n        && y > rect.y\n        && x < ( rect.w + rect.x )\n        && y < ( rect.h + rect.y )\n    ) {\n        return true;\n    }\n    return false;\n}\n\nconst getCanvasEvent = ( event: MouseEvent ): { x: number, y: number} => {\n    const canvasRect = canvasDOM.getBoundingClientRect();\n    return { x: event.clientX - canvasRect.left, y: event.clientY - canvasRect.top }\n}\n\nconst triggerComponentSelect = (): void => {\n    if( canvasDOM ) {\n        const event = new CustomEvent('cwComponentSelected', { \n            detail:  { \n                index: dragCompIndex, \n                component: cwComponents[dragCompIndex] \n            } \n        });\n        canvasDOM.dispatchEvent( event );\n    }\n}","import { BoxComponent, CanvasComponent, CanvasData } from \"../Dtos/canvas.dtos\";\nimport { debounce, log } from \"./common.utils\";\nimport { DestroyDraggable, RegisterDraggable } from \"./draggable.utils\";\nimport { TimeLogger } from \"./timeLogger.utils\";\nimport { drawBoxComponent, drawSelectionHandle } from './draw.utils';\n\nlet forceStopDebug = true;\nlet debug = ! forceStopDebug && process.env.NODE_ENV === 'development';\n\nlet parentDOM: HTMLDivElement;\nlet canvasDOM: HTMLCanvasElement;\nlet ctx: CanvasRenderingContext2D | null;\nlet cwMode: 'editor' | 'viewer';\n\nlet canvasDefaultData = {\n    height: 500,\n    background: '#f5f5f5',\n    hoverColor: '#0000ff',\n    strokeColor: '#000000',\n    selectionStrokeColor: '#7f7f7f',\n    selectionLineWidth: 1,\n    lineWidth: 1,\n    fontSize: 16,\n    fontFamily: 'Arial',\n    borderRadius: 3,\n}\n\nlet canvasData: CanvasData = {}\nlet selectedIndex: number;\n\ninterface InitCanvasProps {\n    parent: HTMLDivElement,\n    canvas: HTMLCanvasElement,\n    mode?: 'editor' | 'viewer',\n    data?: CanvasData,\n}\n\n/**\n * Initialize Canvas.\n * \n * @param parent Parent DOM.\n * @param canvas Main Canvas DOM.\n * @param mode Mode of canvas workflow.\n * @param data Canvas Data. \n */\nexport const InitCanvas = (\n    { \n        parent,\n        canvas,\n        mode,\n        data,\n    } : InitCanvasProps\n) => {\n    parentDOM = parent;\n    canvasDOM = canvas;\n    cwMode = mode || 'editor';\n\n    ctx = canvas.getContext(\"2d\");\n\n    if( data ) {\n        canvasData = data;\n    }\n    \n    canvasRender();\n    if( cwMode === 'editor' && canvasData?.components?.length ) {\n        RegisterDraggable( canvasDOM, canvasData.components, canvasRender );\n    } else {\n        DestroyDraggable();\n    }\n    window.addEventListener( 'resize', debouncRender );\n    canvasDOM.addEventListener( 'cwComponentSelected', handleComponentSelect );\n}\n\n/**\n * Destroy the canvas events.\n */\nexport const DestroyCanvas = () => {\n    window.removeEventListener( 'resize', debouncRender );\n    canvasDOM.removeEventListener( 'cwComponentSelected', handleComponentSelect );\n    DestroyDraggable();\n    if( debug ) {\n        log('Canvas Destroyed');\n    }\n}\n\n/**\n * Clear Canvas.\n */\nexport const ClearCanvas = () => {\n    if( canvasDOM && ctx ) {\n        ctx.clearRect(0, 0, canvasDOM.width, canvasDOM.height);\n        if( debug ) {\n            log('Canvas Cleared!');\n        }\n    }\n}\n\nconst handleComponentSelect = ( event: CustomEvent ) => {\n    selectedIndex = event.detail.index;\n    canvasRender();\n}\n\n/**\n * Debounce the render function for performance optimization.\n */\nconst debouncRender = debounce( () => canvasRender() );\n\n/**\n * Main render function for canvas.\n */\nconst canvasRender = ( ) => {\n    if( parentDOM && canvasDOM && ctx ) {\n        let parentDim = parentDOM.getBoundingClientRect();\n        canvasDOM.width = parentDim.width;\n        canvasDOM.height = canvasData.height || canvasDefaultData.height;\n    \n        ClearCanvas();\n    \n        if( debug ) {\n            log('Rendering...');\n            log('Data:', {canvasData, canvasDefaultData} );\n            TimeLogger.start();\n        }\n        \n        setCanvasBG();\n\n        if( canvasData?.components ) {\n            canvasData.components.forEach( ( component ) => {\n                renderComponents(component);\n            } );\n        }\n\n        if( debug ) {\n            TimeLogger.stop('Render');\n            log('Render Completed');\n        }\n    }\n}\n\n/**\n * Fill background of canvas.\n */\nconst setCanvasBG = () => {\n    if( canvasDOM && ctx ) {\n        ctx.translate(0.5, 0.5); // Smoothening canvas.\n        ctx.fillStyle = canvasData.background || canvasDefaultData.background;\n        ctx.fillRect(0, 0, canvasDOM.width, canvasDOM.height);\n    }\n}\n\n/**\n * Render component in canvas.\n * @param component Canvas Component\n */\nconst renderComponents = ( component: CanvasComponent ) => {\n    processBaseComponent( component );\n    switch( component.type ) {\n        case 'box':\n            drawBoxComponent( component as BoxComponent, canvasDefaultData, ctx );\n            break;\n    }\n    drawSelectionHandle( component, canvasData, selectedIndex, canvasDefaultData, cwMode, ctx );\n}\n\n/**\n * Process Base of component.\n * \n * @param component Canvas Component.\n */\nconst processBaseComponent = ( component: CanvasComponent ) => {\n    // Register editor mode.\n    if( cwMode === 'editor' ) {\n        \n    }\n}","import { SELECTION_BOX_OFFSET } from \"../Constants/canvas.constants\";\nimport { BorderRadius, BoxComponent, CanvasComponent, CanvasData } from \"../Dtos/canvas.dtos\";\nimport { formatBorderRadius, getSelectionBoxCords, log } from \"./common.utils\";\n\n\n/**\n * Draw Box component.\n * \n * @param component Box Component\n * @returns void\n */\nexport const drawBoxComponent = ( component: BoxComponent, canvasDefaultData: any,  ctx?: CanvasRenderingContext2D | null ) => {\n    if( ! ctx ) return;\n\n    const padding = 5;\n    const fontSize = component.fontSize || canvasDefaultData.fontSize;\n\n    ctx.save(); // Save the default state to restore later.\n    ctx.beginPath();\n    drawRoundedRect( ctx, component.x, component.y, component.w, component.h, component.borderRadius || canvasDefaultData.borderRadius );\n    if( component.fillColor ) {\n        // Draw box fill\n        ctx.fillStyle = component.fillColor;\n        ctx.fill();\n    }\n\n    // Draw box stroke or border.\n    ctx.lineWidth = component.lineWidth || canvasDefaultData.lineWidth;\n    ctx.strokeStyle = component.strokeColor || component.fillColor || canvasDefaultData.strokeColor;\n    ctx.stroke();\n    ctx.clip(); // Clip inner elements inside box.\n\n    // Draw box text.\n    ctx.font = `${fontSize}px ${component.fontFamily}`;\n    ctx.fillStyle = component.textColor || canvasDefaultData.strokeColor;\n    ctx.fillText( \n        component.title, \n        component.x + padding + ctx.lineWidth, \n        component.y + padding + fontSize + ctx.lineWidth - 5,\n    );\n    \n    if( component.description ) {\n        printAtWordWrap( \n            ctx,\n            component.description,\n            component.x + padding + ctx.lineWidth,\n            component.y + (padding * 2) + (fontSize * 2) + ctx.lineWidth - 5,\n            fontSize,\n            component.w - (padding * 2) - ctx.lineWidth,\n        );\n    }\n    ctx.restore(); // Restore default state.\n}\n\n\nexport const drawRoundedRect = ( ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, borderRadius?: BorderRadius ) => {\n    const radius = formatBorderRadius( borderRadius );\n    ctx.moveTo(x + radius.tl, y);\n    ctx.lineTo(x + width - radius.tr, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\n    ctx.lineTo(x + width, y + height - radius.br);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\n    ctx.lineTo(x + radius.bl, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\n    ctx.lineTo(x, y + radius.tl);\n    ctx.quadraticCurveTo(x, y, x + radius.tl, y);\n    ctx.closePath();\n}\n\n/**\n * Draw box selection border or indicator.\n * \n * @param component Canvas Component\n */\nexport const drawSelectionHandle = ( component: CanvasComponent, canvasData: CanvasData, selectedIndex: number, canvasDefaultData: any, cwMode: 'editor' | 'viewer', ctx?: CanvasRenderingContext2D | null ) => {\n    if( \n        ctx \n        && cwMode === 'editor'\n        && selectedIndex > -1 \n        && canvasData.components?.length \n        && selectedIndex === canvasData.components.indexOf(component) \n    ) {\n        let dashedLine = true;\n        let compDimension = {\n            x: component.x,\n            y: component.y,\n            w: 0,\n            h: 0,\n        }\n\n        switch( component.type ) {\n            case 'box':\n                const comp = component as BoxComponent;\n                compDimension.w = comp.w;\n                compDimension.h = comp.h;\n                // dashedLine = false;\n                break;\n        }\n\n        // Draw border for selections.\n        ctx.save();\n        ctx.beginPath();\n        ctx.lineWidth = canvasData.selectionLineWidth || canvasDefaultData.selectionLineWidth;\n        if( dashedLine ) {\n            ctx.setLineDash([5, 5])\n        }\n        ctx.strokeStyle = canvasData.selectionStrokeColor || canvasDefaultData.selectionStrokeColor;\n        ctx.rect( \n            compDimension.x - SELECTION_BOX_OFFSET, \n            compDimension.y - SELECTION_BOX_OFFSET,\n            compDimension.w + (SELECTION_BOX_OFFSET * 2),\n            compDimension.h + (SELECTION_BOX_OFFSET * 2),\n        )\n        ctx.stroke();\n        ctx.restore();\n\n        // Draw border points\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = canvasData.selectionStrokeColor || canvasDefaultData.selectionStrokeColor;\n        \n        const selectionBoxes = getSelectionBoxCords( compDimension );\n        for( let box of selectionBoxes ) {\n            ctx.rect( box.x, box.y, box.w, box.h );\n        }\n\n        ctx.fill();\n        ctx.restore();\n    }\n}\n\nexport const printAtWordWrap = ( ctx: CanvasRenderingContext2D , text: string, x: number, y: number, lineHeight: number, fitWidth?: number) => {\n    fitWidth = fitWidth || 0;\n    \n    if (fitWidth <= 0)\n    {\n        ctx.fillText( text, x, y );\n        return;\n    }\n    var words = text.split(' ');\n    var currentLine = 0;\n    var idx = 1;\n    while (words.length > 0 && idx <= words.length)\n    {\n        var str = words.slice(0,idx).join(' ');\n        var w = ctx.measureText(str).width;\n        if ( w > fitWidth )\n        {\n            if (idx==1)\n            {\n                idx=2;\n            }\n            ctx.fillText( words.slice(0,idx-1).join(' '), x, y + (lineHeight * currentLine) );\n            currentLine++;\n            words = words.splice(idx-1);\n            idx = 1;\n        }\n        else\n        {idx++;}\n    }\n    if  (idx > 0)\n        ctx.fillText( words.join(' '), x, y + (lineHeight * currentLine) );\n}","import React, { createRef, useEffect, useState } from 'react'\nimport { BoxComponent, CanvasData } from './Dtos/canvas.dtos';\nimport './styles.scss'\nimport { DestroyCanvas, InitCanvas } from './Utils/canvas.utils';\nimport { log } from './Utils/common.utils';\n\ninterface Props {\n    mode?: 'editor' | 'viewer';\n    defaultData?: CanvasData;\n    data?: CanvasData;\n    onDataChange?( data: CanvasData ): void;\n}\n\nconst ConvasWorkflow = ({ mode = 'editor', defaultData, data, onDataChange }: Props) => {\n\n    const [cwMode, setCwMode] = useState(mode);\n    const [cwData, setCwData] = useState<CanvasData | undefined>(data || defaultData);\n\n    const canvasRef = createRef<HTMLCanvasElement>();\n    const parentRef = createRef<HTMLDivElement>();\n\n    useEffect(() => {\n        setCwMode(mode);\n        setCwData(data);\n    }, [mode, data])\n\n    useEffect(() => {\n        if( canvasRef.current && parentRef.current ) {\n            InitCanvas({\n                parent: parentRef.current,\n                canvas: canvasRef.current,\n                mode: cwMode,\n                data: cwData,\n            });\n        }\n\n        return () => {\n            DestroyCanvas();\n        }\n    }, [canvasRef, parentRef, cwMode, cwData ])\n\n    const addRandomBox = () => {\n        const randomX = Math.floor( Math.random() * ( canvasRef.current?.width || 100 ) );\n        const randomY = Math.floor( Math.random() * ( canvasRef.current?.height || 100 ) );\n        // const randomRadius = Math.floor( Math.random() * 15 );\n\n        const comp: BoxComponent = {\n            type: 'box',\n            title: 'Random',\n            description: 'Random ' + randomX + ':' + randomY,\n            x: randomX,\n            y: randomY,\n            w: 150,\n            h: 100,\n            fillColor: '#ffffff',\n            strokeColor: '#ccc',\n            borderRadius: 2,\n        }\n        setCwData( { ...cwData, components: [ ...cwData?.components || [], comp ] })\n    }\n\n    const clearAll = () => {\n        setCwData( { ...cwData, components: [] } );\n    }\n\n    return (\n        <div className={`canvas-workflow`} >\n            <div className='cw-tools'>\n                <div className=''>\n                    <div>Tool Box</div>\n                </div>\n            </div>\n            <div className='cw-wrapper' ref={parentRef}>\n                <canvas ref={canvasRef}></canvas>\n            </div>\n            <div className='cw-settings'>\n                <div onClick={()=>setCwMode('viewer')}>settings</div>\n                <button onClick={addRandomBox}>Add Random Box</button>\n                <button onClick={clearAll}>Clear All</button>\n            </div>\n        </div>\n    )\n}\n\nexport default ConvasWorkflow;","import React, { useEffect, useState } from 'react'\n\nimport CanvasWorkflow from 'canvas-workflow'\nimport { CanvasData } from 'canvas-workflow/dist/Dtos/canvas.dtos'\nimport 'canvas-workflow/dist/index.css'\n\nconst App = () => {\n    const [data, setData] = useState<CanvasData>();\n\n    useEffect(() => {\n        setData({\n            components:[\n                { \n                    type: 'box',\n                    title: 'Rumesh',\n                    description: 'Hello my name is rumesh udash',\n                    x: 100,\n                    y: 100,\n                    w: 150,\n                    h: 100,\n                    fillColor: 'red',\n                    strokeColor: 'green',\n                    lineWidth: 1,\n                    borderRadius: 5,\n                }\n            ]\n        })\n    }, [])\n\n    const dataChangeHandle = ( data: CanvasData ) => {\n        setData( data );\n    }\n\n    return (\n        <div>\n            <CanvasWorkflow mode='editor' data={data} onDataChange={dataChangeHandle} />\n            {/* <CanvasWorkflow mode='viewer' data={data} /> */}\n        </div>\n    )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}