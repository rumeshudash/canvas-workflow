{"version":3,"sources":["../../src/Constants/canvas.constants.tsx","../../src/Utils/common.utils.tsx","../../src/Utils/draggable.utils.tsx","../../src/Utils/canvas.utils.tsx","../../src/Utils/draw.utils.tsx","../../src/Components/Collapse/collapse.component.tsx","../../src/Utils/image.utils.tsx","../../src/Components/Toolbar/toolbar.component.tsx","../../src/Components/Inputs/Textarea/textarea.component.tsx","../../src/Components/Inputs/NumberInput/numberInput.component.tsx","../../src/Components/Inputs/ColorPicker/colorPicker.component.tsx","../../src/Components/Inputs/SliderInput/sliderInput.component.tsx","../../src/Components/Settings/settings.component.tsx","../../src/index.tsx","App.tsx","index.tsx"],"names":["CANVAS_COLOR_LIST","SELECTION_RESIZE_BOX_CURSORS","reversedIndexOf","length","arr","index","getSelectionBoxCords","boxCords","i","boxCord","x","y","w","h","compDimension","SELECTION_RESIZE_BOX_SIZE","SELECTION_BOX_OFFSET","FontDetector","baseFonts","document","s","defaultWidth","defaultHeight","this","detected","font","matched","getSnapCords","Math","getUniqueKey","getRandomValue","window","crypto","Uint32Array","getLineAngle","dy","ey","dx","ex","theta","getDrawLineButtonCords","cords","component","optionsLength","buttonSize","getComponentByKey","components","Array","comp","reduceLineSize","t0","deduct","start","end","getLinePath","startComp","line","endComp","startOptionCoords","points","lastJoints","rectCollision","rect","dist","x1","y1","linePointCollision","buffer","collided","linePoints","linePath","lineLen","dist1","point","dist2","drawRoundedRect","radius","defaultBorder","tl","tr","br","bl","borderRadius","formatBorderRadius","ctx","drawLine","tension","joints","p0","p2","fPoint0","fPoint1","joint","lastJoint","angle","drawArrowHead","drawLineHover","size","isDragging","isResizing","listenMovingCanvas","isMovingCanvas","isDrawingLine","isMovingJoint","isLineHover","dragCompIndex","dragLineIndex","resizeBoxIndex","startDrawLineIndex","offset","resizePrevCompPos","prevCursorPos","lineStartPos","DestroyDraggable","canvasDOM","onMouseDown","canvasEvent","getCanvasCursorPos","tempComponents","cwComponents","object","arrowBoxes","box","OPTION_HEIGHT","cwData","revLines","revComponents","selectionBoxes","triggerComponentSelect","triggerLineSelect","onMouseMove","cursorChangeX","cursorChangeY","cwRender","cursorChangeReverseX","cursorChangeReverseY","originalIndex","selectionBoxActive","onMouseUp","dropedIndex","componentKey","optionKey","targetKey","onKeyDown","event","tempIndex","setTimeout","removeComponent","onKeyUp","allowDrop","onDrop","id","cursorPos","boxData","key","type","title","description","lineWidth","fillColor","options","name","getDefaultBoxData","canvasRect","top","CustomEvent","detail","canvasDefaultData","selectionStrokeColor","selectionLineWidth","canvasData","InitCanvas","parent","canvas","mode","data","onDataChange","parentDOM","cwMode","handleDataChange","canvasRender","RegisterDraggable","RemoveComponent","tempData","handleComponentSelect","selectedIndex","handleLineSelect","lineSelectedIndex","debouncRender","func","timeout","args","timer","debounce","triggerDataChange","parentDim","pixelRatio","getDevicePixelRatio","setCanvasBG","vw","vh","dot_size","drawCanvasDotGrid","renderComponents","renderLine","fontSize","fitWidth","words","text","currentLine","idx","str","lineHeight","printAtWordWrap","padding","optionDim","OPTION_FONT_SIZE","option","drawBoxComponent","arrowBox","drawSelectionHandle","drawLineSelectionHandle","Collapse","children","useState","collapsed","setCollapsed","className","onClick","duration","height","Toolbar","draggable","onDragStart","React","style","display","src","alt","Textarea","value","placeholder","onChange","setData","e","NumberInput","defaultValue","min","max","onBlur","val","setVal","useEffect","handleChange","handleBlur","parseInt","ColorPicker","colors","transparentBG","showPopup","setShowPopup","boxRef","useRef","popupRef","boxBound","pickerWidth","colorBoxStyle","colorFilStyle","background","backgroundImage","ref","color","presetColors","width","SliderWithTooltip","createSliderWithTooltip","SliderInput","onAfterChange","Settings","canvasRef","selection","setSelection","setComponent","fonts","setFonts","forceUpdate","useReducer","availableList","detector","getAvailableFontList","handleSelectionChange","handleComponentDataChange","newComponent","defaultChecked","handleComponentOptionChange","confirmation","removeOption","newOption","setCwMode","setCwData","createRef","parentRef","otherObject","objKeys","Object","otherKeys","objKey","IsEqualObject","tabIndex","App","innerHeight","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.e3bfe09f.chunk.js","sourcesContent":["export const CANVAS_HEIGHT = 500;\nexport const MIN_CANVAS_HEIGHT = 250;\nexport const CANVAS_GRID_SIZE = 10;\nexport const CANVAS_GRID_COLOR = '#697689';\nexport const DEFAULT_SHOW_GRID = true;\nexport const CANVAS_BG = '#f5f5f5';\nexport const CANVAS_COLOR_LIST = [\n    '#ffffff', \n    '#f5f5f5', \n    '#D9E3F0',\n    '#cccccc', \n    '#697689', \n    '#555555', \n    '#000000',\n    '#ff8a65', \n    '#F47373', \n    '#37D67A', \n    '#2CCCE4', \n    '#dce775', \n    '#ba68c8', \n    'transparent',\n];\n\nexport const SELECTION_BOX_OFFSET = 3;\nexport const SELECTION_RESIZE_BOX_SIZE = 7;\nexport const SELECTION_RESIZE_BOX_CURSORS = [ \n    'nwse-resize', \n    'ns-resize', \n    'nesw-resize', \n    'ew-resize',\n    'nwse-resize',\n    'ns-resize',\n    'nesw-resize',\n    'ew-resize',\n];\n\nexport const BOX_MIN_WIDTH = 50;\nexport const BOX_MIN_HEIGHT = 50;\n\nexport const FONT_SIZE = 16;\nexport const MIN_FONT_SIZE = 8;\nexport const MAX_FONT_SIZE = 70;\nexport const FONT_FAMILY = 'Arial';\nexport const TEXT_COLOR = '#000000';\nexport const STROKE_COLOR = '#cccccc';\nexport const BORDER_RADIUS = 2;\nexport const MAX_BORDER_RADIUS = 20;\nexport const LINE_WIDTH = 1;\nexport const MAX_LINE_WIDTH = 10;\nexport const LINE_HOVER_COLOR = '#1cb2f5a0';\nexport const LINE_HOVER_WIDTH = 7;\n\nexport const OPTION_BG_COLOR = '#f9fad0';\nexport const OPTION_FONT_SIZE = 12;\nexport const OPTION_HEIGHT = 20;\nexport const OPTION_TEXT_COLOR = '#000000';","import { CANVAS_GRID_SIZE, OPTION_HEIGHT, SELECTION_BOX_OFFSET, SELECTION_RESIZE_BOX_SIZE } from \"../Constants/canvas.constants\";\nimport { BorderRadius, BorderRadiusBase, BoxComponent, CanvasComponent, CanvasLine, Point } from \"../Dtos/canvas.dtos\";\n\n/**\n * Log tag.\n */\nconst logTag = 'CanvasWorkflow:';\n\n/**\n * Debounce the given function.\n * \n * @param func Function.\n * @param timeout Timeout in ms.\n * @returns Function.\n */\nexport function debounce(func: Function, timeout = 300){\n    let timer: number;\n    return (...args: any[]) => {\n        window.clearTimeout(timer);\n        timer = window.setTimeout(() => { func.apply(this, args); }, timeout);\n    };\n}\n\n/**\n * Checks if two given objects are same \n * NOTE: Mainly used in persitance for identifying if two params are same\n * @param  {object} object\n * @param  {object} otherObject\n */\nexport function IsEqualObject(object: any, otherObject: any) {\n    let objKeys = Object.keys(object || {}),\n        otherKeys = Object.keys(otherObject || {});\n    \n    // Check length of object matches.\n    if (objKeys.length !== otherKeys.length) {\n        return false;\n    }\n\n    // Check index keys matches.\n    for( let objKey in objKeys ) {\n        if( objKeys[objKey] !== otherKeys[objKey] ) {\n            return false;\n        }\n    }\n\n    // Check array inside object.\n    for( let objKey of objKeys ) {\n        if( Array.isArray( object[objKey] ) ) {\n            if( object[objKey].length !== otherObject[objKey].length ) {\n                return false;\n            }\n\n            for( let i = 0; i < object[objKey].length; i++ ) {\n                if( object[objKey][i] !== otherObject[objKey][i] ) {\n                    return false;\n                }\n            }\n        } else if( object[objKey] !== otherObject[objKey] ) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Get reversed index of item in array.\n * \n * @param arr Arrays\n * @param item Item in array\n * @returns number\n */\nexport const reversedIndexOf = ( arr: any[], item: any): number => {\n    const { length } = arr;\n    const index = arr.indexOf(item);\n    if(index === -1){\n       return -1;\n    };\n    return length - index - 1;\n};\n\n/**\n * Format the border radius.\n * \n * @param borderRadius BorderRadius\n * @returns BorderRadiusBase\n */\nexport const formatBorderRadius = ( borderRadius?: BorderRadius ): BorderRadiusBase => {\n    const defaultBorder = { tl: 0, tr: 0, br: 0, bl: 0 };\n\n    if( typeof borderRadius === 'undefined' ) {\n        return defaultBorder;\n    }\n\n    if( typeof borderRadius !== 'number' ) {\n        return { ...defaultBorder, ...borderRadius };\n    }\n    \n    return { \n        tl: borderRadius as number, \n        tr: borderRadius as number, \n        br: borderRadius as number, \n        bl: borderRadius as number \n    };\n}\n\n/**\n * Get selection box coordinates.\n * \n * @param compDimension Component Dimension.\n * @param strokeOffset Selection stroke offset.\n * @param boxSize Box size.\n * @returns Array\n */\nexport const getSelectionBoxCords = ( compDimension: { x: number, y: number, w: number, h: number } ): { x: number, y: number, w: number, h: number }[] => {\n    let boxCords: { x: number, y: number, w: number, h: number }[] = [];\n\n    for( let i = 1; i <= 8; i++ ) {\n        let boxCord = {\n            x: 0,\n            y: 0,\n            w: SELECTION_RESIZE_BOX_SIZE,\n            h: SELECTION_RESIZE_BOX_SIZE,\n        }\n\n        if( [ 1, 7, 8 ].includes(i) ) {\n            boxCord.x = compDimension.x - SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 2, 6 ].includes(i) ) {\n            boxCord.x = compDimension.x + ( compDimension.w / 2 ) + ( SELECTION_BOX_OFFSET / 2 ) - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 3, 4, 5 ].includes(i) ) {\n            boxCord.x = compDimension.x + compDimension.w + SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        }\n\n        if( [ 1, 2, 3 ].includes(i) ) {\n            boxCord.y = compDimension.y - SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 4, 8 ].includes(i) ) {\n            boxCord.y = compDimension.y + ( compDimension.h / 2 ) + ( SELECTION_BOX_OFFSET / 2 ) - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 5, 6, 7 ].includes(i) ) {\n            boxCord.y = compDimension.y + compDimension.h + SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        }\n\n        boxCords.push( boxCord );\n    }\n\n    return boxCords;\n}\n\n/**\n * Get Device pixel ratio.\n * \n * @param ctx Canvas Rendering Context 2D.\n * @returns number\n */\nexport const getDevicePixelRatio = ( ctx: CanvasRenderingContext2D ) => {\n    let dpr = window.devicePixelRatio || 1,\n        bsr = ( ctx as any ).webkitBackingStorePixelRatio ||\n            ( ctx as any ).mozBackingStorePixelRatio ||\n            ( ctx as any ).msBackingStorePixelRatio ||\n            ( ctx as any ).oBackingStorePixelRatio ||\n            ( ctx as any ).backingStorePixelRatio || 1;\n\n    return dpr / bsr;\n};\n\n// https://stackoverflow.com/a/3368855/9784022\n/**\n * JavaScript code to detect available availability of a\n * particular font in a browser using JavaScript and CSS.\n */\nvar FontDetector = function() {\n    // a font will be compared against all the three default fonts.\n    // and if it doesn't match all 3 then that font is not available.\n    const baseFonts = ['monospace', 'sans-serif', 'serif'];\n\n    //we use m or w because these two characters take up the maximum width.\n    // And we use a LLi so that the same matching fonts can get separated\n    const testString = \"mmmmmmmmmmlli\";\n\n    //we test using 72px font size, we may use any size. I guess larger the better.\n    const testSize = '72px';\n\n    const h = document.getElementsByTagName(\"body\")[0];\n\n    // create a SPAN in the document to get the width of the text we use to test\n    const s = document.createElement(\"span\");\n    s.style.fontSize = testSize;\n    s.innerHTML = testString;\n    let defaultWidth = {};\n    let defaultHeight = {};\n    for (let index in baseFonts) {\n        //get the default width for the three base fonts\n        s.style.fontFamily = baseFonts[index];\n        h.appendChild(s);\n        defaultWidth[baseFonts[index]] = s.offsetWidth; //width for the default font\n        defaultHeight[baseFonts[index]] = s.offsetHeight; //height for the defualt font\n        h.removeChild(s);\n    }\n\n    function detect(font: string) {\n        let detected = false;\n        for (let index in baseFonts) {\n            s.style.fontFamily = font + ',' + baseFonts[index]; // name of the font along with the base font for fallback.\n            h.appendChild(s);\n            const matched = (s.offsetWidth != defaultWidth[baseFonts[index]] || s.offsetHeight != defaultHeight[baseFonts[index]]);\n            h.removeChild(s);\n            detected = detected || matched;\n        }\n        return detected;\n    }\n\n    this.detect = detect;\n    return this;\n} as any;\n\n/**\n * Get list of available fonts.\n * \n * @returns string[]\n */\nexport const getAvailableFontList = (): string[] => {\n    let availableList: string[] = [];\n    let detector = new FontDetector();\n    const fontList = [\n        // Windows 10\n        'Arial', 'Arial Black', 'Bahnschrift', 'Calibri', 'Cambria', 'Cambria Math', 'Candara', 'Comic Sans MS', 'Consolas', 'Constantia', 'Corbel', 'Courier New', 'Ebrima', 'Franklin Gothic Medium', 'Gabriola', 'Gadugi', 'Georgia', 'HoloLens MDL2 Assets', 'Impact', 'Ink Free', 'Javanese Text', 'Leelawadee UI', 'Lucida Console', 'Lucida Sans Unicode', 'Malgun Gothic', 'Marlett', 'Microsoft Himalaya', 'Microsoft JhengHei', 'Microsoft New Tai Lue', 'Microsoft PhagsPa', 'Microsoft Sans Serif', 'Microsoft Tai Le', 'Microsoft YaHei', 'Microsoft Yi Baiti', 'MingLiU-ExtB', 'Mongolian Baiti', 'MS Gothic', 'MV Boli', 'Myanmar Text', 'Nirmala UI', 'Palatino Linotype', 'Segoe MDL2 Assets', 'Segoe Print', 'Segoe Script', 'Segoe UI', 'Segoe UI Historic', 'Segoe UI Emoji', 'Segoe UI Symbol', 'SimSun', 'Sitka', 'Sylfaen', 'Symbol', 'Tahoma', 'Times New Roman', 'Trebuchet MS', 'Verdana', 'Webdings', 'Wingdings', 'Yu Gothic',\n        // macOS\n        'American Typewriter', 'Andale Mono', 'Arial', 'Arial Black', 'Arial Narrow', 'Arial Rounded MT Bold', 'Arial Unicode MS', 'Avenir', 'Avenir Next', 'Avenir Next Condensed', 'Baskerville', 'Big Caslon', 'Bodoni 72', 'Bodoni 72 Oldstyle', 'Bodoni 72 Smallcaps', 'Bradley Hand', 'Brush Script MT', 'Chalkboard', 'Chalkboard SE', 'Chalkduster', 'Charter', 'Cochin', 'Comic Sans MS', 'Copperplate', 'Courier', 'Courier New', 'Didot', 'DIN Alternate', 'DIN Condensed', 'Futura', 'Geneva', 'Georgia', 'Gill Sans', 'Helvetica', 'Helvetica Neue', 'Herculanum', 'Hoefler Text', 'Impact', 'Lucida Grande', 'Luminari', 'Marker Felt', 'Menlo', 'Microsoft Sans Serif', 'Monaco', 'Noteworthy', 'Optima', 'Palatino', 'Papyrus', 'Phosphate', 'Rockwell', 'Savoye LET', 'SignPainter', 'Skia', 'Snell Roundhand', 'Tahoma', 'Times', 'Times New Roman', 'Trattatello', 'Trebuchet MS', 'Verdana', 'Zapfino',\n    ].sort();\n\n    for( let font of fontList ) {\n        if( ! availableList.includes( font ) && detector.detect( font ) ) {\n            availableList.push( font );\n        }\n    }\n\n    return availableList;\n}\n\n/**\n * Custom Log with tag.\n * \n * @param message Any values to log.\n */\nexport const log = ( ...message: any[] ): void => {\n    console.log( logTag, ...message );\n}\n\nexport const getDefaultBoxData = ( x?: number, y?: number ) => {\n    let boxData: BoxComponent = { \n        key: getUniqueKey(),\n        type: 'box',\n        title: 'Workflow',\n        description: 'Your workflow description here.',\n        x: 100,\n        y: 100,\n        w: 150,\n        h: 100,\n        lineWidth: 1,\n        fillColor: '#ffffff',\n        options: [\n            { \n                key: getUniqueKey(),\n                name: 'Always',\n            },\n        ]\n    };\n\n    if( typeof x !== 'undefined' ) {\n        boxData.x = x - ( boxData.w / 2 );\n    }\n    if( typeof y !== 'undefined' ) {\n        boxData.y = y - ( boxData.h / 2 );\n    }\n\n    const cords = getSnapCords( boxData.x, boxData.y );\n    boxData.x = cords.x;\n    boxData.y = cords.y;\n\n    return boxData;\n}\n\n/**\n * Get Snapped coordinates.\n * \n * @param x X coord.\n * @param y Y coord.\n * @returns {x: number, y: number}\n */\nexport const getSnapCords = ( x: number, y: number ) => {\n    return { \n        x: Math.round( x / CANVAS_GRID_SIZE ) * CANVAS_GRID_SIZE, \n        y: Math.round( y / CANVAS_GRID_SIZE ) * CANVAS_GRID_SIZE\n    };\n}\n\n/**\n * Get Snapped size coordinates.\n * \n * @param w Width coord.\n * @param h Height coord.\n * @returns { w: number, h: number }\n */\nexport const getSnapSize = ( w: number, h: number ) => {\n    return {\n        w: Math.round( w / CANVAS_GRID_SIZE ) * CANVAS_GRID_SIZE, \n        h: Math.round( h / CANVAS_GRID_SIZE ) * CANVAS_GRID_SIZE\n    };\n}\n\n/**\n * Get Unique key.\n * \n * @returns String\n */\nexport const getUniqueKey = () => {\n    return getRandomValue().toString(36);\n}\n\n/**\n * Get random value.\n * \n * @returns number\n */\nexport const getRandomValue = () => {\n    const crypto = window.crypto || (window as any).msCrypto;\n    return crypto.getRandomValues(new Uint32Array(1))[0];\n}\n\n/**\n * Get angle of line in degree.\n * \n * @param cx Starting line X coord.\n * @param cy Starting line Y coord.\n * @param ex Ending line X coord.\n * @param ey Ending line Y coord.\n * @returns number\n */\nexport const getLineAngle = ( cx: number, cy: number, ex: number, ey: number ) => {\n    var dy = ey - cy;\n    var dx = ex - cx;\n    var theta = Math.atan2(dy, dx);\n    theta *= 180 / Math.PI;\n    if (theta < 0) theta = 360 + theta; // range [0, 360)\n    return theta;\n}\n\nexport const getDrawLineButtonCords = ( component: CanvasComponent ): any[] => {\n    let cords = [];\n    if( component.options ) {\n        const optionsLength = component.options.length;\n        const buttonSize = 16;\n\n        for( let i = 1; i <= optionsLength; i++ ) {\n            cords.push({\n                x: component.x + component.w + 5,\n                y: component.y + component.h - ( OPTION_HEIGHT * i ) + ( (OPTION_HEIGHT - buttonSize) / 2 ),\n                w: buttonSize + 4,\n                h: buttonSize,\n            });\n        }\n    }\n\n    return cords;\n}\n\nexport const getComponentByKey = ( key: string, components: CanvasComponent[] ) => {\n    if( components && Array.isArray( components ) ) {\n        return components.find( comp => comp.key === key );\n    }\n    return null;\n}\n\nexport const getOptionCoordsByKey = ( key: string, component?: CanvasComponent | null ) => {\n    if( component ) {\n        return getDrawLineButtonCords( component ).reverse().find( ( _, index ) => component.options && component.options[index].key === key );\n    }\n    return null;\n}\n\nexport const reduceLineSize = ( start: { x: number, y: number}, end: { x: number, y: number }, deduct: number ) => {\n    const length = Math.sqrt( Math.pow( start.x - end.x, 2 ) + Math.pow( start.y - end.y, 2 ) );\n    const t0 = 1 - deduct / length;\n    return { x: start.x + t0 * ( end.x - start.x ), y: start.y + t0 * ( end.y - start.y ) };\n}\n\nexport const getLinePath = ( line: CanvasLine, components?: CanvasComponent[] ) => {\n    const startComp = getComponentByKey( line.componentKey, components || [] );\n    const endComp = getComponentByKey( line.targetKey, components || [] );\n    const startOptionCoords = getOptionCoordsByKey( line.optionKey, startComp );\n\n    let points: any = null;\n    let lastJoints: any = null;\n\n    if( startComp && endComp && startOptionCoords ) {\n        if( line.joints && line.joints.length > 0 ) {\n            lastJoints = line.joints[ line.joints.length - 1 ];\n        }\n\n        points = {\n            start: {\n                x: lastJoints ? lastJoints.x : startOptionCoords.x - 5,\n                y: lastJoints ? lastJoints.y : startOptionCoords.y + (startOptionCoords.h / 2),\n            },\n            end: { \n                x: endComp.x,\n                y: endComp.y,\n            }\n        }\n\n        // When target goes right.\n        if( points.start.x + 50 < endComp.x ) {\n            points.end.y = endComp.y + (endComp.h / 2);\n        }\n        // When target goes left.\n        if( points.start.x > endComp.x ) {\n            points.end.x = endComp.x + (endComp.w / 2);\n        }\n        // When target goes fully left of box.\n        if( (points.start.x - startComp.w) > endComp.x ) {\n            points.end.x = endComp.x + endComp.w;\n        }\n        // When target goes fully above of box.\n        if( points.start.y > (endComp.y + endComp.h) ) {\n            points.end.y = endComp.y + endComp.h;\n        }\n        // When target goes fully left of box.\n        if( (points.start.x - startComp.w) > (endComp.x + endComp.w) ) {\n            points.end.y = endComp.y + (endComp.h / 2);\n        }\n\n        points.start = {\n            x: startOptionCoords.x - 5,\n            y: startOptionCoords.y + (startOptionCoords.h / 2),\n        };\n    }\n\n    return points;\n}\n\n/**\n * Rectangular collision detection.\n * \n * @param x Cursor X.\n * @param y Cursor Y\n * @param rect Rectangle coords.\n * @returns boolean\n */\nexport const rectCollision = ( x: number, y: number, rect: { x: number, y: number, w: number, h: number } ): boolean => {\n    if(\n        x > rect.x\n        && y > rect.y\n        && x < ( rect.w + rect.x )\n        && y < ( rect.h + rect.y )\n    ) {\n        return true;\n    }\n    return false;\n}\n\nconst dist = ( x1: number, y1: number, x2: number, y2: number ) =>  Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);\n\nexport const linePointCollision = ( point: Point, linePath: { start: Point, end: Point }, joints?: Point[], buffer = 0.2 ) => {\n    let collided = false;\n    let linePoints = [ linePath.start ];\n\n    if( joints ) {\n        linePoints = linePoints.concat( joints );\n    }\n    linePoints.push( linePath.end );\n\n    for( let i = 1; i < linePoints.length; i++ ) {\n        let start = { ...linePoints[i - 1] };\n\n        const lineLen = dist( start.x, start.y, linePoints[i].x, linePoints[i].y );\n        const dist1 = dist( start.x, start.y, point.x, point.y );\n        const dist2 = dist( linePoints[i].x, linePoints[i].y, point.x, point.y );\n        \n        if( dist1 + dist2 >= lineLen - buffer && dist1 + dist2 <= lineLen + buffer ) {\n            collided = true;\n            break;\n        }\n    }\n\n    return collided;\n}","import { BOX_MIN_HEIGHT, BOX_MIN_WIDTH, OPTION_HEIGHT, SELECTION_RESIZE_BOX_CURSORS } from \"../Constants/canvas.constants\";\nimport { CanvasComponent, CanvasData, CanvasLine } from \"../Dtos/canvas.dtos\";\nimport { getDefaultBoxData, getDrawLineButtonCords, getLinePath, getSelectionBoxCords, getSnapCords, getSnapSize, linePointCollision, rectCollision, reversedIndexOf } from \"./common.utils\";\nimport { drawLine, drawLineHover } from \"./draw.utils\";\n\nlet cwRender: Function;\nlet canvasDOM: HTMLCanvasElement;\nlet cwComponents: CanvasComponent[];\nlet cwData: CanvasData;\nlet tempComponents: CanvasComponent[];\n\nlet removeComponent: ( index: number ) => void;\n\nlet isDragging = false;\nlet isResizing = false;\nlet listenMovingCanvas = false;\nlet isMovingCanvas = false;\nlet isDrawingLine = false;\nlet isMovingJoint = false;\nlet isLineHover = false;\n\nlet dragCompIndex = -1;\nlet dragLineIndex = -1;\nlet resizeBoxIndex = -1;\nlet startDrawLineIndex = -1;\n\nlet offset = {x: 0, y: 0};\nlet resizePrevCompPos = {x: 0, y: 0, w: 0, h: 0};\nlet prevCursorPos = {x: 0, y: 0};\nlet lineStartPos = {x: 0, y: 0};\n\n/**\n * Register draggable events.\n * \n * @param canvas Canvas\n * @param components Component array\n * @param render Render function of canvas.\n */\nexport const RegisterDraggable = ( canvas: HTMLCanvasElement, canvasData: CanvasData, render: Function, RemoveComponent: ( index: number ) => void ): void => {\n    cwComponents = canvasData.components || [];\n    cwData = canvasData;\n    canvasDOM = canvas;\n    cwRender = render;\n    removeComponent = RemoveComponent;\n\n    canvasDOM.addEventListener('mousedown', onMouseDown );\n    canvasDOM.addEventListener('mousemove', onMouseMove );\n    canvasDOM.addEventListener('keydown', onKeyDown );\n    canvasDOM.addEventListener('keyup', onKeyUp );\n    canvasDOM.addEventListener('drop', onDrop );\n    canvasDOM.addEventListener('dragover', allowDrop );\n}\n\n/**\n * Destroy draggable events.\n */\nexport const DestroyDraggable = (): void => {\n    if( canvasDOM ) {\n        canvasDOM.removeEventListener('mousedown', onMouseDown );\n        canvasDOM.removeEventListener('mousemove', onMouseMove );\n        canvasDOM.removeEventListener('keypress', onKeyDown );\n        canvasDOM.removeEventListener('dragover', allowDrop );\n    }\n}\n\n/**\n * Mouse down event.\n * \n * @param event MouseEvent\n */\nconst onMouseDown = ( event: MouseEvent ): void => {\n    const canvasEvent = getCanvasCursorPos( event );\n\n    // Move canvas\n    if( listenMovingCanvas && ! isMovingCanvas ) {\n        isMovingCanvas = true;\n        prevCursorPos = { ...canvasEvent };\n        tempComponents = cwComponents.map(object => ({ ...object }));\n        canvasDOM.style.cursor = 'grabbing';\n        canvasDOM.addEventListener('mouseup', onMouseUp );\n        return;\n    }\n\n    if( ! isMovingCanvas && ! isDragging && !isDrawingLine && dragCompIndex > -1 ) {\n\n        const arrowBoxes = getDrawLineButtonCords( cwComponents[dragCompIndex] );\n        arrowBoxes.reverse().every( ( box, index ) => {\n            if( rectCollision(canvasEvent.x, canvasEvent.y, box ) ) {\n                lineStartPos.x = box.x - 5;\n                lineStartPos.y = box.y + ( OPTION_HEIGHT / 2 );\n                isDrawingLine = true;\n                startDrawLineIndex = index;\n                canvasDOM.addEventListener('mouseup', onMouseUp );\n                return false;\n            }\n            return true;\n        } );\n    }\n\n    if( ! isMovingJoint && cwData.lines ) {\n        const revLines = [...cwData.lines].reverse();\n        for( let line of revLines ) {\n            const linePath = getLinePath( line, cwComponents );\n            if( linePath && linePointCollision( canvasEvent, linePath, line.joints ) ) {\n                dragLineIndex = reversedIndexOf( revLines, line );\n                isMovingJoint = true;\n                canvasDOM.addEventListener('mouseup', onMouseUp );\n                break;\n            }\n        }\n    }\n\n    if( ! isMovingJoint ) {\n        const revComponents = [ ...cwComponents ].reverse();\n        // Loop each components for hit.\n        for( let comp of revComponents ) {\n            let compDimension = {\n                x: comp.x,\n                y: comp.y,\n                w: comp.w,\n                h: comp.h,\n            }\n    \n            if( ! isDragging && rectCollision(canvasEvent.x, canvasEvent.y, compDimension ) ) {\n                isDragging = true;\n                dragCompIndex = reversedIndexOf( revComponents, comp );\n                offset.x = canvasEvent.x - comp.x;\n                offset.y = canvasEvent.y - comp.y;\n    \n                canvasDOM.addEventListener('mouseup', onMouseUp );\n                break;\n            }\n    \n            if( ! isResizing && dragCompIndex !== -1 ) {\n                const selectionBoxes = getSelectionBoxCords( compDimension );\n                // Loop each selection boxes for hit.\n                selectionBoxes.every( ( box, index ) => {\n                    if( rectCollision(canvasEvent.x, canvasEvent.y, box ) ) {\n                        isResizing = true;\n                        prevCursorPos = { ...canvasEvent };\n                        resizePrevCompPos = { ...compDimension };\n                        resizeBoxIndex = index;\n    \n                        canvasDOM.addEventListener('mouseup', onMouseUp );\n                        return false;\n                    }\n    \n                    return true;\n                } )\n                // Break loop for components if resizing.\n                if( isResizing ) {\n                    break;\n                }\n            }\n        }\n    }\n\n    if( ! isDragging && ! isResizing && ! isDrawingLine ) {\n        dragCompIndex = -1;\n        resizeBoxIndex = -1;\n        startDrawLineIndex = -1;\n    }\n\n    if( ! isMovingJoint ) {\n        dragLineIndex = -1;\n    }\n    \n    triggerComponentSelect();\n    triggerLineSelect();\n}\n\n/**\n * Mouse move event.\n * \n * @param event MouseEvent\n */\nconst onMouseMove = ( event: MouseEvent ): void => {\n    const canvasEvent = getCanvasCursorPos( event );\n    const ctx = canvasDOM.getContext('2d');\n\n    if( listenMovingCanvas ) {\n        if( isMovingCanvas ) {\n\n            // Move canvas.\n            let cursorChangeX = prevCursorPos.x - canvasEvent.x;\n            let cursorChangeY = prevCursorPos.y - canvasEvent.y;\n\n            for( let index = 0; index < cwComponents.length; index++ ) {\n                const cords = getSnapCords( tempComponents[index].x - cursorChangeX, tempComponents[index].y - cursorChangeY );\n                cwComponents[index].x = cords.x;\n                cwComponents[index].y = cords.y;\n            }\n            cwRender();\n        }\n    } else if( isDrawingLine && ! isDragging && ! isResizing && dragCompIndex !== -1 && ctx ) {\n        canvasDOM.style.cursor = 'grabbing';\n        cwRender();\n        drawLine( ctx, { start: lineStartPos, end: canvasEvent } );\n    } else if( isDragging && ! isResizing && dragCompIndex !== -1 ) {\n\n        // Drag component.\n        const cords = getSnapCords( canvasEvent.x - offset.x, canvasEvent.y - offset.y );\n        cwComponents[dragCompIndex].x = cords.x;\n        cwComponents[dragCompIndex].y = cords.y;\n        cwRender();\n    } else if( isResizing && dragCompIndex !== -1 ) {\n\n        // Resize box draw.\n        let cursorChangeX = prevCursorPos.x - canvasEvent.x;\n        let cursorChangeY = prevCursorPos.y - canvasEvent.y;\n\n        let cursorChangeReverseX = canvasEvent.x - prevCursorPos.x;\n        let cursorChangeReverseY = canvasEvent.y - prevCursorPos.y;\n\n        if( [ 0, 6, 7 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].x = resizePrevCompPos.x - cursorChangeX;\n            cwComponents[dragCompIndex].w = resizePrevCompPos.w + cursorChangeX;\n        }\n        if( [ 0, 1, 2 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].y = resizePrevCompPos.y - cursorChangeY;\n            cwComponents[dragCompIndex].h = resizePrevCompPos.h + cursorChangeY;\n        }\n        if( [ 2, 3, 4 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].w = resizePrevCompPos.w + cursorChangeReverseX;\n        }\n        if( [ 4, 5, 6 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].h = resizePrevCompPos.h + cursorChangeReverseY;\n        }\n\n        // Maintain minimum weidth and height.\n        if( cwComponents[dragCompIndex].w <= BOX_MIN_WIDTH ) {\n            cwComponents[dragCompIndex].w = BOX_MIN_WIDTH;\n        }\n        if( cwComponents[dragCompIndex].h <= BOX_MIN_HEIGHT ) {\n            cwComponents[dragCompIndex].h = BOX_MIN_HEIGHT;\n        }\n\n        const cords = getSnapCords( cwComponents[dragCompIndex].x, cwComponents[dragCompIndex].y );\n        const size = getSnapSize( cwComponents[dragCompIndex].w, cwComponents[dragCompIndex].h );\n\n        cwComponents[dragCompIndex].x = cords.x;\n        cwComponents[dragCompIndex].y = cords.y;\n        cwComponents[dragCompIndex].w = size.w;\n        cwComponents[dragCompIndex].h = size.h;\n\n        cwRender();\n    } else {\n        canvasDOM.style.cursor = 'default';\n\n        if( ctx && cwData.lines ) {\n\n            if( isLineHover ) {\n                cwRender( false );\n                isLineHover = false;\n            }\n\n            const revLines = [...cwData.lines].reverse();\n\n            revLines.every( line => {\n                const linePath = getLinePath( line, cwComponents );\n                const originalIndex = reversedIndexOf( revLines, line );\n\n                if( linePath &&  linePointCollision( canvasEvent, linePath, line.joints ) ) {\n                    canvasDOM.style.cursor = 'crosshair';\n\n                    if( originalIndex !== dragLineIndex ) {\n                        cwRender( false );\n                        drawLineHover( ctx, linePath, line.joints );\n                        drawLine( ctx, linePath, line.joints );\n                        isLineHover = true;\n                    }\n                    return false;\n                }\n                return true;\n            } )\n        }\n\n        if( dragCompIndex > -1 ) {\n            getDrawLineButtonCords( cwComponents[dragCompIndex] ).every( ( box ) => {\n                if( rectCollision(canvasEvent.x, canvasEvent.y, box ) ) {\n                    canvasDOM.style.cursor = 'grab';\n                    return false;\n                }\n                return true;\n            } );\n        }\n\n        cwComponents.every( ( comp, index ) => {\n            let compDimension = {\n                x: comp.x,\n                y: comp.y,\n                w: comp.w,\n                h: comp.h,\n            }\n\n            if( rectCollision(canvasEvent.x, canvasEvent.y, compDimension ) ) {\n                canvasDOM.style.cursor = 'move'; // On hover over draggable box.\n                return false;\n            }\n\n            let selectionBoxActive = false;\n            if( index === dragCompIndex ) {\n                const selectionBoxes = getSelectionBoxCords( compDimension );\n                selectionBoxes.every( ( box, index ) => {\n                    if( rectCollision(canvasEvent.x, canvasEvent.y, box ) ) {\n                        canvasDOM.style.cursor = SELECTION_RESIZE_BOX_CURSORS[index] || 'move';\n                        selectionBoxActive = true;\n                        return false;\n                    }\n                    return true;\n                } )\n            }\n\n            if( selectionBoxActive ) return false;\n            return true;\n        } );\n    }\n}\n\n/**\n * Mouse up event.\n */\nconst onMouseUp = ( event: MouseEvent ): void => {\n    const canvasEvent = getCanvasCursorPos( event );\n\n    if ( isMovingCanvas ) {\n        canvasDOM.style.cursor = 'grab';\n    }\n    if( isDrawingLine ) {\n        canvasDOM.style.cursor = 'grab';\n        const revComponents = [ ...cwComponents ].reverse();\n        for( let comp of revComponents ) {\n            let compDimension = {\n                x: comp.x,\n                y: comp.y,\n                w: comp.w,\n                h: comp.h,\n            }\n    \n            if( rectCollision(canvasEvent.x, canvasEvent.y, compDimension ) ) {\n                const dropedIndex = reversedIndexOf( revComponents, comp );\n                if(  dropedIndex !== dragCompIndex ) {\n                    const startComp = cwComponents[dragCompIndex];\n\n                    if( startComp.options && startComp.options.length ) {\n                        const line: CanvasLine = {\n                            componentKey: startComp.key,\n                            optionKey: startComp.options[startDrawLineIndex].key,\n                            targetKey: cwComponents[dropedIndex].key,\n                            joints: [],\n                        }\n                        if( cwData.lines && cwData.lines.length ) {\n                            cwData.lines.push( line );\n                        } else {\n                            cwData.lines = [ line ];\n                        }\n                    }\n                }\n                break;\n            }\n        }\n    }\n    isDragging = false;\n    isResizing = false;\n    isMovingCanvas = false;\n    isMovingJoint = false;\n    isDrawingLine = false;\n    tempComponents = [];\n    canvasDOM.removeEventListener('mouseup', onMouseUp );\n    cwRender();\n}\n\n/**\n * Key down event.\n * \n * @param event KeyboardEvent\n */\nconst onKeyDown = ( event: KeyboardEvent ): void => {\n    if( event.key === ' ' && ! listenMovingCanvas ) {\n        event.preventDefault();\n        canvasDOM.style.cursor = 'grab'\n        listenMovingCanvas = true;\n    } if( ( event.key.toLowerCase() === 'delete' || event.key.toLowerCase() === 'backspace' ) ) {\n        if( dragLineIndex !== -1 ) {\n            // To-do Remove Line.\n\n            // event.preventDefault();\n            // const tempIndex = dragCompIndex;\n            // dragLineIndex = -1;\n            // setTimeout( () => {\n            //     // removeComponent( tempIndex );\n            //     triggerLineSelect();\n            // }, 100 )\n\n        } else if( dragCompIndex !== -1 ) {\n            event.preventDefault();\n            const tempIndex = dragCompIndex;\n            dragCompIndex = -1;\n            setTimeout( () => {\n                removeComponent( tempIndex );\n                triggerComponentSelect();\n            }, 100 )\n        }\n    }\n}\n\n/**\n * Key up event.\n * \n * @param event KeyboardEvent\n */\nconst onKeyUp = ( event: KeyboardEvent ): void => {\n    if( event.key === ' ' ) {\n        listenMovingCanvas = false;\n        isMovingCanvas = false;\n        tempComponents = [];\n        canvasDOM.style.cursor = 'default'\n    }\n}\n\n/**\n * Allow drop over canvas.\n * \n * @param ev Event\n */\nconst allowDrop = ( event: any ): any => {\n    event.preventDefault();\n} \n\n/**\n * Drop element event.\n * \n * @param event Event\n */\nconst onDrop = ( event: any ) => {\n    event.preventDefault();\n    if( event.dataTransfer ) {\n        const id = event.dataTransfer.getData('id');\n        const cursorPos = getCanvasCursorPos( event );\n\n        switch( id ) {\n            case 'box':\n                const length = cwComponents.push( getDefaultBoxData( cursorPos.x, cursorPos.y ) );\n                dragCompIndex = length - 1;\n                triggerComponentSelect();\n                cwRender();\n                break;\n        }\n    }\n\n}\n\n/**\n * Get cursor position in canvas.\n * \n * @param event MouseEvent\n * @returns object\n */\nconst getCanvasCursorPos = ( event: MouseEvent ): { x: number, y: number} => {\n    const canvasRect = canvasDOM.getBoundingClientRect();\n    return { x: event.clientX - canvasRect.left, y: event.clientY - canvasRect.top }\n}\n\n/**\n * Trigger component select event. 'cwComponentSelected'\n */\nconst triggerComponentSelect = (): void => {\n    if( canvasDOM ) {\n        canvasDOM.dispatchEvent( new CustomEvent('cwComponentSelected', { \n            detail:  { \n                index: dragCompIndex, \n                component: cwComponents[dragCompIndex] \n            } \n        }) );\n    }\n}\n\n/**\n * Trigger line select event. 'cwLineSelected'\n */\n const triggerLineSelect = (): void => {\n    if( canvasDOM ) {\n        canvasDOM.dispatchEvent( new CustomEvent('cwLineSelected', { \n            detail:  { \n                index: dragLineIndex, \n                line: cwData.lines && cwData.lines[dragLineIndex] \n            } \n        }) );\n    }\n}","import { BoxComponent, CanvasComponent, CanvasData, CanvasLine } from \"../Dtos/canvas.dtos\";\nimport { debounce, getDevicePixelRatio, getLinePath, log } from \"./common.utils\";\nimport { DestroyDraggable, RegisterDraggable } from \"./draggable.utils\";\nimport { TimeLogger } from \"./timeLogger.utils\";\nimport { drawBoxComponent, drawCanvasDotGrid, drawLine, drawLineSelectionHandle, drawSelectionHandle } from './draw.utils';\nimport { CANVAS_BG, CANVAS_HEIGHT } from \"../Constants/canvas.constants\";\n\nlet forceStopDebug = true;\nlet debug = ! forceStopDebug && process.env.NODE_ENV === 'development';\n\nlet parentDOM: HTMLDivElement;\nlet canvasDOM: HTMLCanvasElement;\nlet ctx: CanvasRenderingContext2D | null;\nlet handleDataChange: ( data: CanvasData ) => void;\nlet cwMode: 'editor' | 'viewer';\n\nlet canvasDefaultData = {\n    selectionStrokeColor: '#7f7f7f',\n    selectionLineWidth: 1,\n}\n\nlet canvasData: CanvasData = {}\nlet selectedIndex: number;\nlet lineSelectedIndex: number;\n\ninterface InitCanvasProps {\n    parent: HTMLDivElement,\n    canvas: HTMLCanvasElement,\n    mode?: 'editor' | 'viewer',\n    data?: CanvasData,\n    updateData?: ( data: CanvasData ) => void,\n    onDataChange?: ( data: CanvasData ) => void\n}\n\n/**\n * Initialize Canvas.\n * \n * @param parent Parent DOM.\n * @param canvas Main Canvas DOM.\n * @param mode Mode of canvas workflow.\n * @param data Canvas Data. \n */\nexport const InitCanvas = (\n    { \n        parent,\n        canvas,\n        mode,\n        data,\n        onDataChange,\n    } : InitCanvasProps\n) => {\n    parentDOM = parent;\n    canvasDOM = canvas;\n    cwMode = mode || 'editor';\n    ctx = canvas.getContext(\"2d\");\n\n    if( onDataChange ) {\n        handleDataChange = onDataChange;\n    }\n\n    if( data ) {\n        canvasData = data;\n        canvasData.components = canvasData.components || [];\n        canvasData.lines = canvasData.lines || [];\n    }\n    \n    canvasRender( false );\n\n    if( cwMode === 'editor' && canvasData ) {\n        RegisterDraggable( canvasDOM, canvasData, canvasRender, RemoveComponent );\n    } else {\n        DestroyDraggable();\n    }\n    window.addEventListener( 'resize', debouncRender );\n    canvasDOM.addEventListener( 'cwComponentSelected', handleComponentSelect );\n    canvasDOM.addEventListener( 'cwLineSelected', handleLineSelect );\n}\n\n/**\n * Destroy the canvas events.\n */\nexport const DestroyCanvas = () => {\n    window.removeEventListener( 'resize', debouncRender );\n    DestroyDraggable();\n    if( debug ) {\n        log('Canvas Destroyed');\n    }\n}\n\n/**\n * Remove component from canvas data.\n * @param index Component index\n */\nexport const RemoveComponent = ( index: number ) => {\n    if( canvasData?.components ) {\n        let tempData = { ...canvasData };\n        tempData.components = tempData.components?.filter( ( _, i ) => {\n            return i !== index;\n        } );\n        canvasData = tempData;\n        handleDataChange( tempData );\n    }\n}\n\n/**\n * Clear Canvas.\n */\nexport const ClearCanvas = () => {\n    if( canvasDOM && ctx ) {\n        ctx.clearRect(0, 0, canvasDOM.width, canvasDOM.height);\n        if( debug ) {\n            log('Canvas Cleared!');\n        }\n    }\n}\n\nconst handleComponentSelect = ( event: CustomEvent ) => {\n    if( selectedIndex !== event.detail.index ) {\n        selectedIndex = event.detail.index;\n        canvasRender( false );\n    }\n}\n\nconst handleLineSelect = ( event: CustomEvent ) => {\n    if( lineSelectedIndex !== event.detail.index ) {\n        lineSelectedIndex = event.detail.index;\n        canvasRender( false );\n    }\n}\n\n/**\n * Debounce the render function for performance optimization.\n */\nconst debouncRender = debounce( () => canvasRender() );\n\n/**\n * Main render function for canvas.\n */\nexport const canvasRender = ( triggerDataChange = true ) => {\n    if( parentDOM && canvasDOM && ctx ) {\n        let parentDim = parentDOM.getBoundingClientRect();\n        let pixelRatio = getDevicePixelRatio( ctx ); // Device pixel ratio.\n\n        // Manage pixel ratio of canvas according to device pixel ratio.\n        canvasDOM.width = parentDim.width * pixelRatio;\n        canvasDOM.height = ( canvasData.height || CANVAS_HEIGHT ) * pixelRatio;\n        canvasDOM.style.width = parentDim.width + \"px\";\n        canvasDOM.style.height = ( canvasData.height || CANVAS_HEIGHT ) + \"px\";\n        ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n        ClearCanvas();\n    \n        if( debug ) {\n            log('Rendering...');\n            log('Data:', {canvasData, canvasDefaultData} );\n            TimeLogger.start();\n        }\n        \n        setCanvasBG();\n\n        // Draw canvas grid.\n        drawCanvasDotGrid( canvasData, canvasDOM, ctx );\n\n        // Render components.\n        if( canvasData?.components ) {\n            canvasData.components.forEach( ( component ) => {\n                renderComponents(component);\n            } );\n        }\n\n        // Render lines.\n        if( canvasData?.lines ) {\n            canvasData.lines.forEach( ( line ) => {\n                renderLine(line);\n            } );\n        }\n\n        if( debug ) {\n            TimeLogger.stop('Render');\n            log('Render Completed');\n        }\n\n        // Handle data change.\n        if( triggerDataChange ) {\n            handleDataChange( canvasData );\n        }\n    }\n}\n\n/**\n * Fill background of canvas.\n */\nconst setCanvasBG = () => {\n    if( canvasDOM && ctx ) {\n        ctx.translate(0.5, 0.5); // Smoothening canvas.\n        ctx.fillStyle = canvasData.background || CANVAS_BG;\n        ctx.fillRect(0, 0, canvasDOM.width, canvasDOM.height);\n    }\n}\n\n/**\n * Render component in canvas.\n * @param component Canvas Component\n */\nconst renderComponents = ( component: CanvasComponent ) => {\n    processBaseComponent( component );\n    switch( component.type ) {\n        case 'box':\n            drawBoxComponent( component as BoxComponent, ctx );\n            break;\n    }\n    drawSelectionHandle( component, canvasData, selectedIndex, canvasDefaultData, cwMode, ctx );\n}\n\n/**\n * Render component in canvas.\n * @param component Canvas Component\n */\nconst renderLine = ( line: CanvasLine ) => {\n    const linePath = getLinePath( line, canvasData.components );\n\n    if( ctx && linePath ) {\n        drawLine( ctx, linePath, line.joints, 10 );\n    }\n    \n    drawLineSelectionHandle( line, canvasData, lineSelectedIndex, cwMode, ctx );\n}\n\n/**\n * Process Base of component.\n * \n * @param component Canvas Component.\n */\nconst processBaseComponent = ( component: CanvasComponent ) => {\n    // Register editor mode.\n    if( cwMode === 'editor' && ctx ) {\n        // drawLine( ctx, { start: {x: 10, y: 10 }, end: { x: 100, y: 10 } } )\n    }\n}","import { \n    BORDER_RADIUS, \n    CANVAS_GRID_COLOR, \n    CANVAS_GRID_SIZE, \n    DEFAULT_SHOW_GRID, \n    FONT_FAMILY, \n    FONT_SIZE, \n    LINE_WIDTH, \n    OPTION_BG_COLOR, \n    OPTION_FONT_SIZE, \n    OPTION_TEXT_COLOR, \n    OPTION_HEIGHT,\n    SELECTION_BOX_OFFSET, \n    STROKE_COLOR, \n    TEXT_COLOR, \n    LINE_HOVER_COLOR,\n    LINE_HOVER_WIDTH\n} from \"../Constants/canvas.constants\";\nimport { BorderRadius, BoxComponent, CanvasComponent, CanvasData, CanvasLine } from \"../Dtos/canvas.dtos\";\nimport { formatBorderRadius, getLineAngle, getSelectionBoxCords, getDrawLineButtonCords, reduceLineSize, getLinePath } from \"./common.utils\";\n\n/**\n * Draw Canvas Dot grid.\n*/\nexport const drawCanvasDotGrid = ( canvasData: CanvasData, canvasDOM?: HTMLCanvasElement, ctx?: CanvasRenderingContext2D | null ) => {\n    if( ! canvasDOM || ! ctx ) return;\n    if( ! ( typeof canvasData.showGrid !== 'undefined' ? canvasData.showGrid : DEFAULT_SHOW_GRID ) ) return;\n\n    const dot_size = 1,\n        vw = canvasDOM.width,\n        vh = canvasDOM.height;\n\n    for (var x = 0; x < vw + CANVAS_GRID_SIZE; x+= CANVAS_GRID_SIZE ) {\n        for (var y = 0; y < vh + CANVAS_GRID_SIZE; y+= CANVAS_GRID_SIZE) {\n            ctx.fillStyle = canvasData.gridColor || CANVAS_GRID_COLOR;\n            ctx.fillRect( x - (dot_size / 2), y - (dot_size / 2), dot_size, dot_size );\n        }\n    }\n}\n\n/**\n * Draw rounded rect ( With border radius ).\n * \n * @param ctx Context.\n * @param x Rect X Coord.\n * @param y Rect Y Coord.\n * @param width Width of rect.\n * @param height Height of rect.\n * @param borderRadius Border radius of rect.\n */\nexport const drawRoundedRect = ( ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, borderRadius?: BorderRadius ) => {\n    const radius = formatBorderRadius( borderRadius );\n    ctx.moveTo(x + radius.tl, y);\n    ctx.lineTo(x + width - radius.tr, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\n    ctx.lineTo(x + width, y + height - radius.br);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\n    ctx.lineTo(x + radius.bl, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\n    ctx.lineTo(x, y + radius.tl);\n    ctx.quadraticCurveTo(x, y, x + radius.tl, y);\n    ctx.closePath();\n}\n\n/**\n * Draw box selection border or indicator.\n * \n * @param component Canvas Component\n */\nexport const drawSelectionHandle = ( component: CanvasComponent, canvasData: CanvasData, selectedIndex: number, canvasDefaultData: any, cwMode: 'editor' | 'viewer', ctx?: CanvasRenderingContext2D | null ) => {\n    if( \n        ctx \n        && cwMode === 'editor'\n        && selectedIndex > -1 \n        && canvasData.components?.length \n        && selectedIndex === canvasData.components.indexOf(component) \n    ) {\n        let dashedLine = true;\n        let compDimension = {\n            x: component.x,\n            y: component.y,\n            w: 0,\n            h: 0,\n        }\n\n        switch( component.type ) {\n            case 'box':\n                compDimension.w = (component as BoxComponent).w;\n                compDimension.h = (component as BoxComponent).h;\n                break;\n        }\n\n        // Draw border for selections.\n        ctx.save();\n        ctx.beginPath();\n        ctx.lineWidth = canvasData.selectionLineWidth || canvasDefaultData.selectionLineWidth;\n        if( dashedLine ) {\n            ctx.setLineDash([5, 5])\n        }\n        ctx.strokeStyle = canvasData.selectionStrokeColor || canvasDefaultData.selectionStrokeColor;\n        ctx.rect( \n            compDimension.x - SELECTION_BOX_OFFSET, \n            compDimension.y - SELECTION_BOX_OFFSET,\n            compDimension.w + (SELECTION_BOX_OFFSET * 2),\n            compDimension.h + (SELECTION_BOX_OFFSET * 2),\n        )\n        ctx.stroke();\n        ctx.restore();\n\n        // Draw border points\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = canvasData.selectionStrokeColor || canvasDefaultData.selectionStrokeColor;\n        \n        // Draw selection resize boxes.\n        const selectionBoxes = getSelectionBoxCords( compDimension );\n        for( let box of selectionBoxes ) {\n            ctx.rect( box.x, box.y, box.w, box.h );\n        }\n\n        const drawArrowBoxes = getDrawLineButtonCords ( component );\n        for( let arrowBox of drawArrowBoxes ) {\n            ctx.drawImage( document.getElementById('arrowLineIcon') as any, arrowBox.x, arrowBox.y, arrowBox.w, arrowBox.h );\n        }\n\n        ctx.fill();\n        ctx.restore();\n    }\n}\n\n/**\n * Draw line selection border or indicator.\n * \n * @param component Canvas Component\n */\n export const drawLineSelectionHandle = ( line: CanvasLine, canvasData: CanvasData, lineSelectedIndex: number, cwMode: 'editor' | 'viewer', ctx?: CanvasRenderingContext2D | null ) => {\n    if( \n        ctx \n        && cwMode === 'editor'\n        && lineSelectedIndex > -1 \n        && canvasData.lines?.length \n        && lineSelectedIndex === canvasData.lines.indexOf(line) \n    ) {\n        const linePath = getLinePath( line, canvasData.components );\n        drawLineHover( ctx, linePath, line.joints );\n        drawLine( ctx, linePath, line.joints );\n    }\n}\n\n/**\n * Draw Text/Word with word wrap.\n * \n * @param ctx Context\n * @param text Text to draw\n * @param x Text X Coord.\n * @param y Text Y Coord.\n * @param lineHeight Text line height.\n * @param fitWidth Width to fit text.\n * @returns void\n */\nexport const printAtWordWrap = ( ctx: CanvasRenderingContext2D , text: string, x: number, y: number, lineHeight: number, fitWidth?: number) => {\n    fitWidth = fitWidth || 0;\n    \n    if (fitWidth <= 0)\n    {\n        ctx.fillText( text, x, y );\n        return;\n    }\n    var words = text.split(' ');\n    var currentLine = 0;\n    var idx = 1;\n    while (words.length > 0 && idx <= words.length)\n    {\n        var str = words.slice(0,idx).join(' ');\n        var w = ctx.measureText(str).width;\n        if ( w > fitWidth )\n        {\n            if (idx==1)\n            {\n                idx=2;\n            }\n            ctx.fillText( words.slice(0,idx-1).join(' '), x, y + (lineHeight * currentLine) );\n            currentLine++;\n            words = words.splice(idx-1);\n            idx = 1;\n        }\n        else\n        {idx++;}\n    }\n    if  (idx > 0)\n        ctx.fillText( words.join(' '), x, y + (lineHeight * currentLine) );\n}\n\nexport const drawLine = ( ctx: CanvasRenderingContext2D, points: any, joints?: any[], tension = 10 ) => {\n    ctx.beginPath();\n    ctx.save();\n    ctx.moveTo( points.start.x, points.start.y );\n\n    let lastJoint: any;\n    \n    if( joints && joints.length > 0 ) {\n        joints.forEach( (joint, index) => {\n            let p0 = { ...points.start };\n            let p2 = { ...points.end };\n\n            if( index > 0 ) {\n                p0 = { ...joints[index - 1] };\n            }\n            if( index < joints.length - 1 ) {\n                p2 = { ...joints[ index + 1 ] };\n            }\n\n            const fPoint0 = reduceLineSize( p0, joint, tension );\n            const fPoint1 = reduceLineSize( p2, joint, tension );\n\n            ctx.lineTo( fPoint0.x, fPoint0.y );\n            ctx.quadraticCurveTo( joint.x, joint.y, fPoint1.x, fPoint1.y );\n\n            if( joints.length - 1 == index ) {\n                lastJoint = joint;\n            }\n        } );\n    }\n\n    ctx.lineTo( points.end.x, points.end.y );\n    ctx.stroke();\n\n    let angle = 0;\n    if( lastJoint ) {\n        angle = getLineAngle( lastJoint.x, lastJoint.y, points.end.x, points.end.y );\n    } else {\n        angle = getLineAngle( points.start.x, points.start.y, points.end.x, points.end.y );\n    }\n    drawArrowHead( ctx, points.end.x, points.end.y, 7, angle, '#000' );\n    ctx.restore();\n}\n\nexport const drawLineHover = ( ctx: CanvasRenderingContext2D, points: any, joints?: any[], tension = 10 ) => {\n    ctx.beginPath();\n    ctx.save();\n    ctx.moveTo( points.start.x, points.start.y );\n\n    let lastJoint: any;\n    \n    if( joints && joints.length > 0 ) {\n        joints.forEach( (joint, index) => {\n            let p0 = { ...points.start };\n            let p2 = { ...points.end };\n\n            if( index > 0 ) {\n                p0 = { ...joints[index - 1] };\n            }\n            if( index < joints.length - 1 ) {\n                p2 = { ...joints[ index + 1 ] };\n            }\n\n            const fPoint0 = reduceLineSize( p0, joint, tension );\n            const fPoint1 = reduceLineSize( p2, joint, tension );\n\n            ctx.lineTo( fPoint0.x, fPoint0.y );\n            ctx.quadraticCurveTo( joint.x, joint.y, fPoint1.x, fPoint1.y );\n\n            if( joints.length - 1 == index ) {\n                lastJoint = joint;\n            }\n        } );\n    }\n\n    ctx.strokeStyle = LINE_HOVER_COLOR;\n    ctx.lineWidth = LINE_HOVER_WIDTH;\n    ctx.lineCap = 'round';\n    ctx.lineTo( points.end.x, points.end.y );\n    ctx.stroke();\n    ctx.restore();\n}\n\n/**\n * \n * @param ctx CanvasRenderingContext2D\n * @param x Line end Y.\n * @param y Line end Y.\n * @param size Size of arrow head.\n * @param angle Angle to rotate.\n * @param fillColor Fill color of arrow head.\n */\nexport const drawArrowHead = ( ctx: CanvasRenderingContext2D, x: number, y: number, size: number, angle: number, fillColor: string ) => {\n    ctx.save();\n\n    ctx.translate(x, y);\n    ctx.rotate( angle * Math.PI / 180 );\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo( - size, - ( size / 2 ) );\n    ctx.lineTo( - size, size / 2 );\n    ctx.closePath();\n    ctx.fillStyle = fillColor;\n    ctx.fill();\n\n    ctx.restore();\n}\n\n/**\n * Draw Polygon.\n */\nexport const drawPolygon = (ctx: CanvasRenderingContext2D, centerX: number, centerY: number, sideCount: number, size: number, fillColor = '#000000', rotationDegrees = 0 ) => {\n    ctx.save();\n\n    ctx.translate(centerX,centerY);\n    ctx.rotate( rotationDegrees * Math.PI / 180 );\n    ctx.beginPath();\n    ctx.moveTo (size * Math.cos(0), size * Math.sin(0));          \n    for (var i = 1; i <= sideCount;i += 1) {\n        ctx.lineTo (size * Math.cos(i * 2 * Math.PI / sideCount), size * Math.sin(i * 2 * Math.PI / sideCount));\n    }\n    ctx.closePath();\n    ctx.fillStyle = fillColor;\n    ctx.fill();\n\n    ctx.restore();\n}\n\n/**\n * Draw Box component.\n * \n * @param component Box Component\n * @returns void\n */\nexport const drawBoxComponent = ( component: BoxComponent, ctx?: CanvasRenderingContext2D | null ) => {\n    if( ! ctx ) return;\n\n    const padding = 5;\n    const fontSize = component.fontSize || FONT_SIZE;\n    const borderRadius = typeof component.borderRadius !== \"undefined\" ? component.borderRadius : BORDER_RADIUS ;\n\n    ctx.save(); // Save the default state to restore later.\n    ctx.beginPath();\n    drawRoundedRect( ctx, component.x, component.y, component.w, component.h, borderRadius );\n\n    if( component.fillColor ) {\n        // Draw box fill\n        ctx.fillStyle = component.fillColor || 'transparent';\n        ctx.fill();\n    }\n\n    // Draw box stroke or border.\n    ctx.lineWidth = component.lineWidth || LINE_WIDTH;\n    ctx.strokeStyle = component.strokeColor || STROKE_COLOR;\n    ctx.stroke();\n    ctx.clip('evenodd'); // Clip inner elements inside box.\n\n    // Draw box text.\n    ctx.font = `bold ${fontSize}px ${component.fontFamily || FONT_FAMILY}`;\n    ctx.fillStyle = component.textColor || TEXT_COLOR;\n    ctx.fillText(\n        component.title, \n        component.x + padding + ctx.lineWidth, \n        component.y + padding + fontSize + ctx.lineWidth - 5,\n    );\n    \n    if( component.description ) {\n        ctx.font = `${fontSize}px ${component.fontFamily || FONT_FAMILY}`;\n        printAtWordWrap(\n            ctx,\n            component.description,\n            component.x + padding + ctx.lineWidth,\n            component.y + (padding * 2) + (fontSize * 2) + ctx.lineWidth - 5,\n            fontSize,\n            component.w - (padding * 2) - ctx.lineWidth,\n        );\n    }\n\n    if( component.options ) {\n        const optionsLength = component.options.length;\n\n        component.options.forEach( ( option, index ) => {\n            ctx.fillStyle = OPTION_BG_COLOR;\n            const optionDim = {\n                x: component.x,\n                y: component.y + component.h - ( OPTION_HEIGHT * (optionsLength - index) ),\n                w: component.w,\n                h: OPTION_HEIGHT,\n            }\n            ctx.fillRect( optionDim.x, optionDim.y, optionDim.w, optionDim.h );\n\n            ctx.font = `${OPTION_FONT_SIZE}px ${component.fontFamily || FONT_FAMILY}`;\n            ctx.fillStyle = OPTION_TEXT_COLOR;\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\n                option.name, \n                optionDim.x + ( optionDim.w / 2 ),\n                optionDim.y + ( OPTION_HEIGHT / 2 ),\n            );\n\n            ctx.strokeStyle = component.strokeColor || STROKE_COLOR;\n            ctx.moveTo(component.x, optionDim.y);\n            ctx.lineTo(component.x + component.w, optionDim.y);\n            ctx.stroke();\n        } );\n    }\n\n    ctx.restore(); // Restore default state.\n}","import React, { useState } from 'react';\nimport AnimateHeight from 'react-animate-height';\nimport './collapse.component.scss';\n\ninterface CollapseProps {\n    title: string;\n    children: any;\n}\n\nconst Collapse = ({ title, children }: CollapseProps) => {\n    const [collapsed, setCollapsed] = useState(false);\n\n    return (\n        <div className='collapse'>\n            <div className='title' onClick={ () => setCollapsed( ! collapsed ) }>{title} <span className={`arrow ${ ! collapsed ? 'down' : '' }`}/></div>\n            <AnimateHeight\n                duration={ 500 }\n                height={ collapsed ? 0 : 'auto' }\n            >\n                <div className='controls'>\n                    {children}\n                </div>\n            </AnimateHeight>\n        </div>\n    )\n}\n\nexport default Collapse\n","export const DrawArrowLineIcon = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAAC50lEQVRoge2Zy2oUQRSGvxkTjcZbJG7cieAlwUWIRHQriCgoLsTgI7gTQVBUFFyowQRBVPDyGC5cqYh3XcRJEI0v4IXEYETtZMZFOdh9uqqmq6tneoT+oBen559T/+muqq6uhoKCgqzYCowBFeAbMA2MAyPA5hx9NWQJcBNYAGqGIwBGgY6cPBrpAh5gNi6Pe0BnLk4N3CK5+fpxJRenGgaId5tJ4ACwCugBDgFTxLvTxhz8xrhO1FgFZVzSC3wU2ost8mjlA1FTey3aYaF93XR3DSgBP/lnqIoa0CbWEi3gSysMhhusan4PxO+2KXKxyPcrK6Nlw/mSiGuaeEboe7Iy5YKpgCR8FfE6i1ZeAHmBUuNTwJSIt/gYSYtPAZMi7rNo2/IOVES8zcdI1iwiOmvMazSbhGYa8wXpENogY78xkhRQAj4LXb8hX9MK8OlCNeCZOLfTog3TFmMA4KmId3jmc8a3gCcibvkdMJFkDAB0E19S6J7IZZFvISujaZcSdeaITqclYMjXlAu+XQjguYj/uwJeiFhXQBX4LtrtNuS7kIEnOon22d8Wbb/QfjLo5AvQBoMuAC65W47i8uApo/aBwvr1Gt0jodlvyFefFBIV4TuIQXWPV+LcoEb3UsTDlpwAJ/C4Ey5dCNSmVVh/SqMZIj6V7tLoAqG77G7fvYCjQn9XoykBb4VuDjiOemc2FZCqCNcCdgv9Q4Nuu8FgkmOkmQX0Cf2ERXsMNW4yKSKLQQxqFgqz0qIdA46g3h9cmWksUbhug6wQ+tkEbawGTqKe5LM0vvqnk5oH942rXtGYz8aVboycSZNIbsrusWgPC+2bNA3+RRZwNm2iGyLROKqrSNYQXyb4LAXCBZzzyMMg8dmiAuwDlgHLgYPAe6EJUC/8aXFaSjTiDu5T3ahnmwEpn746lgKPSW7+Pv6fkM57/j9GF3Ab+0e8eeAqbfb9SzIAXAPeAT9Q65gJ1IPJtB9UUFDQZP4APGV4LajhJX4AAAAASUVORK5CYII=';","import React from 'react'\nimport Collapse from '../Collapse/collapse.component';\nimport { ReactComponent as BoxSvg } from '../../Assets/Images/workflowBox.svg'  ;\nimport { DrawArrowLineIcon } from '../../Utils/image.utils';\nimport './toolbar.component.scss';\n\nconst Toolbar = () => {\n\n    const handleDragStart = ( event: any ) => {\n        event.dataTransfer.setData(\"id\", event.target.id );\n    }\n\n    return (\n        <div className='cw-toolbar'>\n            <Collapse title='Standard Shapes'>\n                <div className='tools'>\n                    <div id='box' className='tool-item' draggable=\"true\" onDragStart={ handleDragStart }>\n                        <BoxSvg/>\n                    </div>\n                </div>\n            </Collapse>\n            <div className='image-loader' style={{display: 'none'}}>\n                <img id='arrowLineIcon' src={DrawArrowLineIcon} alt='arrow icon'/>\n            </div>\n        </div>\n    )\n}\n\nexport default Toolbar\n","import React, { useState } from 'react';\nimport './textarea.component.scss';\n\nconst Textarea = (\n    { \n        value, \n        placeholder, \n        onChange \n    }: { \n        value?: string, \n        placeholder?: string,\n        onChange?: ( value: string ) => void \n    }\n) => {\n    const [data, setData] = useState(value);\n\n    return (\n        <div className=\"textarea-wrap\" data-replicated-value={data}>\n            <textarea placeholder={placeholder} onChange={(e) => { setData( e.target.value ); onChange && onChange( e.target.value ) } } value={data}></textarea>\n        </div>\n    )\n}\n\nexport default Textarea;\n","import React, { ChangeEvent, useEffect, useState } from 'react'\n\ninterface NumberInputProps {\n    defaultValue?: number, \n    value?: number, \n    min?: number,\n    max?: number,\n    placeholder?: string,\n    onChange?: ( value: number ) => void,\n    onBlur?: ( value: number ) => void,\n}\n\nconst NumberInput = ({ \n    defaultValue, \n    value, \n    min,\n    max,\n    placeholder,\n    onChange,\n    onBlur, \n}: NumberInputProps ) => {\n\n    const [val, setVal] = useState( defaultValue || 0 );\n\n    useEffect(() => {\n        if( value ) {\n            setVal( value );\n        }\n    }, [value])\n\n    const handleChange = ( data: number ) => {\n        if( typeof onChange !== 'undefined' ){\n            onChange( data );\n        }\n        setVal( data );\n    }\n\n    const handleBlur = ( data: number ) => {\n        if( typeof min !== 'undefined' && data < min ) data = min;\n        if( typeof max !== 'undefined' && data > max ) data = max;\n\n        if( typeof onBlur !== 'undefined' ) {\n            onBlur( data );\n        }\n        setVal( data );\n    }\n\n    return (\n        <input \n            type='number' \n            value={val} \n            placeholder={placeholder} \n            onChange={ ( e ) => handleChange( parseInt(e.target.value) ) } \n            onBlur={ ( e ) => handleBlur( parseInt(e.target.value) ) } \n        />\n    )\n}\n\nexport default NumberInput\n","import React, { Fragment, useEffect, useRef, useState } from 'react'\nimport { SketchPicker, ColorResult } from 'react-color';\nimport './colorPicker.component.scss';\n\ninterface ColorPickerProps {\n    type?: 'fill' | 'stroke',\n    value?: string,\n    colors?: string[],\n    onChange?: ( value: string ) => void;\n}\n\nconst ColorPicker = ({ type = 'fill', colors, value = '#00000000', onChange }: ColorPickerProps ) => {\n\n    const pickerWidth = 172;\n    const transparentBG = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVQ4T2NkYGAQYcAP3uCTZhw1gGGYhAGBZIA/nYDCgBDAm9BGDWAAJyRCgLaBCAAgXwixzAS0pgAAAABJRU5ErkJggg==\";\n\n    const [showPopup, setShowPopup] = useState(false);\n    const [val, setVal] = useState(value);\n\n    const boxRef = useRef<HTMLDivElement>(null);\n    const popupRef = useRef<HTMLDivElement>(null);\n\n    useEffect(() => {\n        if( boxRef.current && popupRef.current ) {\n            const boxBound = boxRef.current.getBoundingClientRect();\n            popupRef.current.style.left = (boxBound.x + (boxBound.width / 2) - (pickerWidth / 2) - 5) + 'px';\n            popupRef.current.style.top = (boxBound.y + boxBound.height + 5) + 'px';\n        }\n    }, [boxRef.current, popupRef.current, showPopup]);\n\n    const handleChange = ( color: ColorResult ) => {\n        if( val !== color.hex && typeof onChange === 'function' ) {\n            onChange( color.hex );\n        }\n        setVal( color.hex );\n    }\n\n    let colorBoxStyle: {} = {};\n    let colorFilStyle: {} = { background: val };\n\n    if( type === 'stroke' ) {\n        if( val === 'transparent' || val === '#00000000' ) {\n            colorBoxStyle = { backgroundImage: `url(${transparentBG})` };\n        } else {\n            colorBoxStyle = { background: val};\n        }\n        colorFilStyle = {};\n    } else {\n        if( val === 'transparent' || val === '#00000000' ) {\n            colorFilStyle = { background: '#ffffff', backgroundImage: `url(${transparentBG})` };\n        }\n    }\n\n\n    return (\n        <div className='color-picker'>\n            <div ref={boxRef} className='color-box' onClick={ () => setShowPopup( ! showPopup ) } style={colorBoxStyle}>\n                <div className='color-fill' style={colorFilStyle} />\n            </div>\n            <div ref={popupRef} className={`popup`}>\n                { showPopup && <Fragment>\n                    <div className='popup-cover' onClick={ () => setShowPopup( false ) }/>\n                    <SketchPicker\n                        color={val}\n                        presetColors={colors && colors}\n                        width={`${pickerWidth}px`} \n                        onChange={handleChange}\n                    />\n                </Fragment>}\n            </div>\n        </div>\n    )\n}\n\nexport default ColorPicker\n","import React from 'react'\nimport Slider, { createSliderWithTooltip } from 'rc-slider';\nimport 'rc-slider/assets/index.css';\nimport './sliderInput.component.scss';\n\ninterface SliderProps {\n    value?: number;\n    min?: number;\n    max?:number;\n    onChange?: ( value: number ) => void;\n    onAfterChange?: ( value: number ) => void;\n}\n\nconst SliderWithTooltip = createSliderWithTooltip(Slider);\n\nconst SliderInput = ({ value, min, max, onChange, onAfterChange } : SliderProps) => {\n    return (\n        <SliderWithTooltip defaultValue={value} min={min} max={max} onChange={onChange} onAfterChange={onAfterChange} />\n    )\n}\n\nexport default SliderInput\n","import React, { useEffect, useReducer, useState } from 'react'\nimport { \n    CANVAS_BG, \n    CANVAS_COLOR_LIST, \n    CANVAS_HEIGHT, \n    FONT_FAMILY, \n    FONT_SIZE, \n    MIN_CANVAS_HEIGHT, \n    MIN_FONT_SIZE, \n    MAX_FONT_SIZE, \n    STROKE_COLOR, \n    TEXT_COLOR, \n    BORDER_RADIUS, \n    MAX_BORDER_RADIUS, \n    LINE_WIDTH, \n    MAX_LINE_WIDTH, \n    DEFAULT_SHOW_GRID,\n    CANVAS_GRID_COLOR\n} from '../../Constants/canvas.constants';\nimport { BoxComponent, CanvasComponent, CanvasData, Option } from '../../Dtos/canvas.dtos';\nimport { canvasRender } from '../../Utils/canvas.utils';\nimport { getAvailableFontList, getUniqueKey } from '../../Utils/common.utils';\nimport { BsPlus, BsTrash } from \"react-icons/bs\";\nimport Textarea from '../Inputs/Textarea/textarea.component';\nimport NumberInput from '../Inputs/NumberInput/numberInput.component';\nimport ColorPicker from '../Inputs/ColorPicker/colorPicker.component';\nimport SliderInput from '../Inputs/SliderInput/sliderInput.component';\nimport Collapse from '../Collapse/collapse.component';\nimport './settings.component.scss';\n\ninterface SettingsProps {\n    data: CanvasData;\n    canvasRef: React.RefObject<HTMLCanvasElement>;\n}\n\nconst Settings = ({ data = {}, canvasRef }: SettingsProps) => {\n\n    const [selection, setSelection] = useState<number>(-1);\n    const [component, setComponent] = useState<CanvasComponent>();\n    const [fonts, setFonts] = useState<string[]>([]);\n    const [, forceUpdate] = useReducer(x => x + 1, 0);\n\n    useEffect(() => {\n        // List of available fonts.\n        setFonts(getAvailableFontList());\n    }, [])\n\n    useEffect(() => {\n        if( canvasRef.current ) {\n            canvasRef.current.addEventListener('cwComponentSelected', handleSelectionChange );\n        }\n        return () => {\n            if( canvasRef.current ) {\n                canvasRef.current.removeEventListener('cwComponentSelected', handleSelectionChange );\n            }\n        }\n    }, [ canvasRef.current, selection ])\n\n    useEffect(() => {\n        if( selection !== -1 && data.components && ! data.components[selection] ) {\n            setSelection( -1 );\n        }\n    }, [data])\n\n    const handleSelectionChange = ( event: CustomEvent ) => {\n        if( selection !== event.detail.index ) {\n            setSelection( event.detail.index );\n            setComponent( undefined );\n            setComponent( event.detail.component );\n            forceUpdate();\n        }\n    }\n\n    let comp: any;\n    if( component && component.type === 'box' ) {\n        comp = component as BoxComponent;\n    }\n    \n    const handleDataChange = ( key: string, value: any ) => {\n        data[key] = value;\n        if( key === 'height' ) {\n            if( value && value < MIN_CANVAS_HEIGHT ) {\n                data[key] = MIN_CANVAS_HEIGHT;\n            } else if( ! value ) {\n                data[key] = CANVAS_HEIGHT;\n            }\n        }\n        forceUpdate();\n        canvasRender();\n    }\n\n    const handleComponentDataChange = ( key: string, value: any ) => {\n        if( selection !== -1 ) {\n            if( data.components && data.components[selection] ) {\n                const newComponent = { ...data.components[selection] };\n                newComponent[key] = value;\n                data.components[selection] = newComponent;\n\n                setComponent( data.components[selection] );\n                canvasRender();\n            }\n        }\n    }\n\n    const handleComponentOptionChange = ( index: number, key: string, value: any ) => {\n        if( selection !== -1 ) {\n            if( data.components && data.components[selection]?.options ) {\n                const newComponent = { ...data.components[selection] };\n                if( newComponent.options && newComponent.options[index] ) {\n                    newComponent.options[index][key] = value;\n                    data.components[selection] = newComponent;\n                    setComponent( data.components[selection] );\n                    canvasRender();\n                }\n            }\n        }\n    }\n\n    const addNewOption = () => {\n        if( data.components && data.components[selection]?.options ) {\n            const newOption: Option = {\n                key: getUniqueKey(),\n                name: 'Always',\n            }\n            const newComponent = { ...data.components[selection] };\n            if( newComponent.options && newComponent.options.length > 0 ) {\n                newComponent.options.push( newOption );\n            } else {\n                newComponent.options = [ newOption ];\n            }\n            data.components[selection] = newComponent;\n            setComponent( data.components[selection] );\n            canvasRender();\n        }\n    }\n\n    const removeOption = ( index: number ) => {\n        const confirmation = window.confirm('Are you sure want to delete this option?');\n        \n        if( confirmation && data.components && data.components[selection]?.options ) {\n            const newComponent = { ...data.components[selection] };\n            if( newComponent.options && newComponent.options.length > 0 ) {\n                if( data.lines && data.lines.length > 0 ) {\n                    // Remove unused line.\n                    data.lines = data.lines.filter( line => newComponent.options && line.optionKey !== newComponent.options[index].key );\n                }\n\n                newComponent.options = newComponent.options.filter( (_, i) => i !== index );\n                data.components[selection] = newComponent;\n                setComponent( data.components[selection] );\n                canvasRender();\n            }\n        }\n    }\n\n    return (\n        <div className='cw-settings'>\n            { selection === -1 &&\n                <div className='canvas-settings'>\n                    <Collapse title='Canvas Settings'>\n                        <div>\n                            <div className='form-group'>\n                                <div className='form-control'>\n                                    <label>Background:</label>\n                                    <ColorPicker \n                                        type='fill'\n                                        value={data.background || CANVAS_BG} \n                                        colors={CANVAS_COLOR_LIST}\n                                        onChange={( value ) => handleDataChange( 'background',value ) } \n                                    />\n                                </div>\n                            </div>\n                            <div className='form-group'>\n                                <div className='form-control'>\n                                    <label>Height:</label>\n                                    <NumberInput\n                                        placeholder='Height'\n                                        min={MIN_CANVAS_HEIGHT}\n                                        value={data.height || CANVAS_HEIGHT}\n                                        onBlur={( value ) => handleDataChange( 'height',value )}\n                                    />\n                                </div>\n                            </div>\n                            <div className='form-group'>\n                                <div className='form-control inline'>\n                                    <label>Show Grid:</label>\n                                    <input \n                                        type='checkbox' \n                                        defaultChecked={typeof data.showGrid !== 'undefined' ? data.showGrid : DEFAULT_SHOW_GRID}\n                                        onChange={ ( e ) => handleDataChange( 'showGrid', e.target.checked )} \n                                    />\n                                </div>\n                            </div>\n                            { ( data.showGrid || ( typeof data.showGrid === 'undefined' && DEFAULT_SHOW_GRID ) ) && \n                                <div className='form-group'>\n                                    <div className='form-control'>\n                                        <label>Grid Color:</label>\n                                        <ColorPicker\n                                            type='fill'\n                                            value={data.gridColor || CANVAS_GRID_COLOR} \n                                            colors={CANVAS_COLOR_LIST}\n                                            onChange={( value ) => handleDataChange( 'gridColor',value ) } \n                                        />\n                                    </div>\n                                </div>\n                            }\n                        </div>\n                    </Collapse>\n                </div>\n            }\n            { selection !== -1 &&\n                <div className='component-settings'>\n                    <Collapse title='Presentation'>\n                        { comp && comp.type === 'box' && <div>\n                            <div className='form-group'>\n                                <div className='form-control'>\n                                    <label>Fill:</label>\n                                    <ColorPicker \n                                        type='fill'\n                                        value={comp.fillColor || 'transparent'} \n                                        colors={CANVAS_COLOR_LIST}\n                                        onChange={( value ) => handleComponentDataChange( 'fillColor',value ) } \n                                    />\n                                </div>\n                                <div className='form-control'>\n                                    <label>Outline:</label>\n                                    <ColorPicker\n                                        type='stroke'\n                                        value={comp.strokeColor || STROKE_COLOR} \n                                        colors={CANVAS_COLOR_LIST}\n                                        onChange={( value ) => handleComponentDataChange( 'strokeColor',value ) } \n                                    />\n                                </div>\n                            </div>\n                            <div className='form-group'>\n                                <div className='form-control'>\n                                    <label>Outline Width: <strong>{ comp.lineWidth || BORDER_RADIUS } px</strong></label>\n                                    <SliderInput\n                                        value={ comp.lineWidth || LINE_WIDTH } \n                                        min={1}\n                                        max={MAX_LINE_WIDTH}\n                                        onAfterChange={( value ) => handleComponentDataChange( 'lineWidth', value )}\n                                    />\n                                </div>\n                            </div>\n                            <div className='form-group'>\n                                <div className='form-control'>\n                                    <label>Border Radius: <strong>{ typeof comp.borderRadius !== 'undefined' ? comp.borderRadius : BORDER_RADIUS } px</strong></label>\n                                    <SliderInput\n                                        value={ typeof comp.borderRadius !== 'undefined' ? comp.borderRadius : BORDER_RADIUS } \n                                        max={MAX_BORDER_RADIUS}\n                                        onAfterChange={( value ) => handleComponentDataChange( 'borderRadius', value )}\n                                    />\n                                </div>\n                            </div>\n                        </div>}\n                    </Collapse>\n                    <Collapse title='Text'>\n                        { comp?.type === 'box' && <div>\n                            <div className='form-group'>\n                                <div className='form-control'>\n                                    <label>Title:</label>\n                                    <input \n                                        type='text' \n                                        placeholder='Title'\n                                        defaultValue={comp.title}\n                                        onChange={(e) => handleComponentDataChange( 'title', e.target.value )}\n                                    />\n                                </div>\n                            </div>\n                            <div className='form-group'>\n                                <div className='form-control'>\n                                    <label>Description:</label>\n                                    <Textarea \n                                        placeholder='Description' \n                                        value={comp.description} \n                                        onChange={(value) => handleComponentDataChange( 'description', value )} \n                                    />\n                                </div>\n                            </div>\n                            <div className='form-group'>\n                                <div className='form-control'>\n                                    <label>Font Size: <strong>{comp.fontSize || FONT_SIZE}px</strong></label>\n                                    <SliderInput\n                                        value={comp.fontSize || FONT_SIZE} \n                                        min={MIN_FONT_SIZE}\n                                        max={MAX_FONT_SIZE}\n                                        onAfterChange={( value ) => handleComponentDataChange( 'fontSize', value )}\n                                    />\n                                </div>\n                            </div>\n                            <div className='form-group'>\n                                <div className='form-control'>\n                                    <label>Font Family:</label>\n                                    <select defaultValue={comp.fontFamily || FONT_FAMILY} onChange={( e ) => handleComponentDataChange( 'fontFamily', e.target.value ) }>\n                                        { fonts.length > 0 && fonts.map( ( font ) => (\n                                            <option key={font} value={font}>{font}</option>\n                                        ) ) }\n                                    </select>\n                                </div>\n                            </div>\n                            <div className='form-group'>\n                                <div className='form-control'>\n                                    <label>Text Color:</label>\n                                    <ColorPicker\n                                        type='fill'\n                                        value={comp.textColor || TEXT_COLOR} \n                                        colors={CANVAS_COLOR_LIST}\n                                        onChange={( value ) => handleComponentDataChange( 'textColor',value ) } \n                                    />\n                                </div>\n                            </div>\n                        </div>}\n                    </Collapse>\n                    <Collapse title='Options'>\n                        <div className='option-list'>\n                            { comp?.options && comp.options.map( ( option: Option, index: number ) => (\n                                <div key={option.key} className='form-group'>\n                                    <div className='form-control inline'>\n                                        <input className='full-width' type='text' defaultValue={option.name} onChange={ (e) => handleComponentOptionChange( index, 'name', e.target.value ) } />\n                                        <button className='btn-link btn-danger' onClick={ () => removeOption(index) }>\n                                            <BsTrash />\n                                        </button>\n                                    </div>\n                                </div>\n                            ) ) }\n                        </div>\n                        <button className='btn-subtle btn-success' onClick={addNewOption}><BsPlus /> Add Option</button>\n                    </Collapse>\n                </div>\n            }\n        </div>\n    )\n}\n\nexport default Settings\n","import React, { createRef, useEffect, useState } from 'react'\nimport { BoxComponent, CanvasData } from './Dtos/canvas.dtos';\nimport { DestroyCanvas, InitCanvas } from './Utils/canvas.utils';\nimport { IsEqualObject } from './Utils/common.utils';\nimport Toolbar from './Components/Toolbar/toolbar.component';\nimport Settings from './Components/Settings/settings.component';\nimport './styles.scss'\n\ninterface Props {\n    mode?: 'editor' | 'viewer';\n    data?: CanvasData;\n    onDataChange?( data: CanvasData ): void;\n}\n\nconst ConvasWorkflow = ({ mode = 'editor', data = {}, onDataChange }: Props) => {\n\n    const [cwMode, setCwMode] = useState(mode);\n    const [cwData, setCwData] = useState<CanvasData>({});\n\n    const canvasRef = createRef<HTMLCanvasElement>();\n    const parentRef = createRef<HTMLDivElement>();\n\n    useEffect(() => {\n        if( cwMode !== mode ) {\n            setCwMode(mode);\n        }\n        if( ! IsEqualObject( data, cwData ) ) {\n            setCwData(data);\n        }\n    }, [mode, data]);\n\n    useEffect(() => {\n        if( canvasRef.current && parentRef.current ) {\n            InitCanvas({\n                parent: parentRef.current,\n                canvas: canvasRef.current,\n                mode: cwMode,\n                data: cwData,\n                onDataChange,\n            });\n        }\n\n        return () => {\n            DestroyCanvas();\n        }\n    }, [canvasRef, parentRef, cwMode, cwData, cwData.components ])\n\n    return (\n        <div className={`canvas-workflow`} >\n            <Toolbar />\n            <div className='cw-wrapper' ref={parentRef}>\n                <canvas ref={canvasRef} tabIndex={1}></canvas>\n            </div>\n            <Settings data={cwData} canvasRef={canvasRef} />\n        </div>\n    )\n}\n\nexport default ConvasWorkflow;","import React, { useEffect, useState } from 'react'\n\nimport CanvasWorkflow from 'canvas-workflow'\nimport { CanvasData } from 'canvas-workflow/dist/Dtos/canvas.dtos'\nimport 'canvas-workflow/dist/index.css'\n\nconst App = () => {\n    const [ data, setData ] = useState<CanvasData>({});\n\n    useEffect(() => {\n        setData( { ...data, height: window.innerHeight } );\n        // eslint-disable-next-line\n    }, []);\n\n    const dataChangeHandle = ( data: CanvasData ) => {\n        setData( data );\n        // console.log( data );\n    }\n\n    return (\n        <div>\n            <CanvasWorkflow mode='editor' data={data} onDataChange={dataChangeHandle} />\n        </div>\n    )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}