{"version":3,"sources":["../../src/Constants/canvas.constants.tsx","../../src/Utils/common.utils.tsx","../../src/Utils/draggable.utils.tsx","../../src/Utils/canvas.utils.tsx","../../src/Utils/draw.utils.tsx","../../src/index.tsx","App.tsx","index.tsx"],"names":["SELECTION_RESIZE_BOX_CURSORS","getSelectionBoxCords","boxCords","i","boxCord","x","y","w","h","compDimension","SELECTION_RESIZE_BOX_SIZE","SELECTION_BOX_OFFSET","isDragging","isResizing","listenMovingCanvas","isMovingCanvas","dragCompIndex","resizeBoxIndex","offset","resizePrevCompPos","prevCursorPos","DestroyDraggable","canvasDOM","onMouseDown","cwComponents","canvasEvent","getCanvasCursorPos","tempComponents","object","revComponents","comp","c","rectCollision","length","arr","index","reversedIndexOf","selectionBoxes","triggerComponentSelect","onMouseMove","cursorChangeX","cursorChangeY","cwRender","cursorChangeReverseX","cursorChangeReverseY","selectionBoxActive","onMouseUp","onKeyDown","event","onKeyUp","rect","canvasRect","top","CustomEvent","detail","component","drawRoundedRect","radius","borderRadius","tl","tr","br","bl","formatBorderRadius","ctx","printAtWordWrap","fitWidth","words","text","currentLine","idx","str","lineHeight","canvasDefaultData","height","background","hoverColor","strokeColor","selectionStrokeColor","selectionLineWidth","lineWidth","fontSize","fontFamily","canvasData","InitCanvas","parent","canvas","mode","data","parentDOM","cwMode","canvasRender","RegisterDraggable","window","handleComponentSelect","selectedIndex","debouncRender","func","timeout","args","timer","debounce","parentDim","setCanvasBG","renderComponents","padding","drawBoxComponent","box","drawSelectionHandle","defaultData","useState","setCwMode","cwData","setCwData","canvasRef","createRef","parentRef","useEffect","className","React","ref","tabIndex","onClick","randomX","Math","randomY","type","title","description","fillColor","components","App","setData","onDataChange","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.da04f15c.chunk.js","sourcesContent":["export const SELECTION_BOX_OFFSET = 3;\nexport const SELECTION_RESIZE_BOX_SIZE = 7;\nexport const SELECTION_RESIZE_BOX_CURSORS = [ \n    'nwse-resize', \n    'ns-resize', \n    'nesw-resize', \n    'ew-resize',\n    'nwse-resize',\n    'ns-resize',\n    'nesw-resize',\n    'ew-resize',\n];\nexport const BOX_MIN_WIDTH = 50;\nexport const BOX_MIN_HEIGHT = 50;","import { SELECTION_BOX_OFFSET, SELECTION_RESIZE_BOX_SIZE } from \"../Constants/canvas.constants\";\nimport { BorderRadius, BorderRadiusBase } from \"../Dtos/canvas.dtos\";\n\n/**\n * Log tag.\n */\nconst logTag = 'CanvasWorkflow:';\n\n/**\n * Debounce the given function.\n * \n * @param func Function.\n * @param timeout Timeout in ms.\n * @returns Function.\n */\nexport function debounce(func: Function, timeout = 300){\n    let timer: number;\n    return (...args: any[]) => {\n        window.clearTimeout(timer);\n        timer = window.setTimeout(() => { func.apply(this, args); }, timeout);\n    };\n}\n\n/**\n * Get reversed index of item in array.\n * \n * @param arr Arrays\n * @param item Item in array\n * @returns number\n */\nexport const reversedIndexOf = ( arr: any[], item: any): number => {\n    const { length } = arr;\n    const index = arr.indexOf(item);\n    if(index === -1){\n       return -1;\n    };\n    return length - index - 1;\n};\n\n/**\n * Format the border radius.\n * \n * @param borderRadius BorderRadius\n * @returns BorderRadiusBase\n */\nexport const formatBorderRadius = ( borderRadius?: BorderRadius ): BorderRadiusBase => {\n    if( typeof borderRadius !== 'number' ) {\n        return { ...{ tl: 0, tr: 0, br: 0, bl: 0 }, ...borderRadius };\n    }\n    \n    return { \n        tl: borderRadius as number, \n        tr: borderRadius as number, \n        br: borderRadius as number, \n        bl: borderRadius as number \n    };\n}\n\n/**\n * Get selection box coordinates.\n * \n * @param compDimension Component Dimension.\n * @param strokeOffset Selection stroke offset.\n * @param boxSize Box size.\n * @returns Array\n */\nexport const getSelectionBoxCords = ( compDimension: { x: number, y: number, w: number, h: number } ): { x: number, y: number, w: number, h: number }[] => {\n    let boxCords: { x: number, y: number, w: number, h: number }[] = [];\n\n    for( let i = 1; i <= 8; i++ ) {\n        let boxCord = {\n            x: 0,\n            y: 0,\n            w: SELECTION_RESIZE_BOX_SIZE,\n            h: SELECTION_RESIZE_BOX_SIZE,\n        }\n\n        if( [ 1, 7, 8 ].includes(i) ) {\n            boxCord.x = compDimension.x - SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 2, 6 ].includes(i) ) {\n            boxCord.x = compDimension.x + ( compDimension.w / 2 ) + ( SELECTION_BOX_OFFSET / 2 ) - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 3, 4, 5 ].includes(i) ) {\n            boxCord.x = compDimension.x + compDimension.w + SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        }\n\n        if( [ 1, 2, 3 ].includes(i) ) {\n            boxCord.y = compDimension.y - SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 4, 8 ].includes(i) ) {\n            boxCord.y = compDimension.y + ( compDimension.h / 2 ) + ( SELECTION_BOX_OFFSET / 2 ) - (SELECTION_RESIZE_BOX_SIZE / 2);\n        } else if( [ 5, 6, 7 ].includes(i) ) {\n            boxCord.y = compDimension.y + compDimension.h + SELECTION_BOX_OFFSET - (SELECTION_RESIZE_BOX_SIZE / 2);\n        }\n\n        boxCords.push( boxCord );\n    }\n\n    return boxCords;\n}\n\n/**\n * Custom Log with tag.\n * \n * @param message Any values to log.\n */\nexport const log = ( ...message: any[] ): void => {\n    console.log( logTag, ...message );\n}\n","import { BOX_MIN_HEIGHT, BOX_MIN_WIDTH, SELECTION_RESIZE_BOX_CURSORS } from \"../Constants/canvas.constants\";\nimport { BoxComponent, CanvasComponent } from \"../Dtos/canvas.dtos\";\nimport { getSelectionBoxCords, log, reversedIndexOf } from \"./common.utils\";\n\nlet cwRender: Function;\nlet canvasDOM: HTMLCanvasElement;\nlet cwComponents: CanvasComponent[];\nlet tempComponents: CanvasComponent[];\n\nlet isDragging = false;\nlet isResizing = false;\nlet listenMovingCanvas = false;\nlet isMovingCanvas = false;\n\nlet dragCompIndex = -1;\nlet resizeBoxIndex = -1;\n\nlet offset = {x: 0, y: 0};\nlet resizePrevCompPos = {x: 0, y: 0, w: 0, h: 0};\nlet prevCursorPos = {x: 0, y: 0};\n\n/**\n * Register draggable events.\n * \n * @param canvas Canvas\n * @param components Component array\n * @param render Render function of canvas.\n */\nexport const RegisterDraggable = ( canvas: HTMLCanvasElement, components: CanvasComponent[], render: Function ): void => {\n    cwComponents = components;\n    canvasDOM = canvas;\n    cwRender = render;\n\n    canvasDOM.addEventListener('mousedown', onMouseDown );\n    canvasDOM.addEventListener('mousemove', onMouseMove );\n    canvasDOM.addEventListener('keydown', onKeyDown );\n    canvasDOM.addEventListener('keyup', onKeyUp );\n}\n\n/**\n * Destroy draggable events.\n */\nexport const DestroyDraggable = (): void => {\n    if( canvasDOM ) {\n        canvasDOM.removeEventListener('mousedown', onMouseDown );\n        canvasDOM.removeEventListener('mousemove', onMouseMove );\n        canvasDOM.removeEventListener('keypress', onKeyDown );\n    }\n}\n\n/**\n * Mouse down event.\n * \n * @param event MouseEvent\n */\nconst onMouseDown = ( event: MouseEvent ): void => {\n    if( ! cwComponents.length ) return;\n\n    const canvasEvent = getCanvasCursorPos( event );\n\n    // Move canvas\n    if( listenMovingCanvas && ! isMovingCanvas ) {\n        isMovingCanvas = true;\n        prevCursorPos = { ...canvasEvent };\n        tempComponents = cwComponents.map(object => ({ ...object }));\n        canvasDOM.style.cursor = 'grabbing';\n        canvasDOM.addEventListener('mouseup', onMouseUp );\n        return;\n    }\n\n    const revComponents = [ ...cwComponents ].reverse();\n    // Loop each components for hit.\n    for( let comp of revComponents ) {\n        let compDimension = {\n            x: comp.x,\n            y: comp.y,\n            w: 0,\n            h: 0,\n        }\n\n        switch( comp.type ) {\n            case 'box':\n                const c = comp as BoxComponent;\n                compDimension.w = c.w;\n                compDimension.h = c.h;\n                break;\n        }\n\n        if( ! isDragging && rectCollision(canvasEvent.x, canvasEvent.y, compDimension ) ) {\n            isDragging = true;\n            dragCompIndex = reversedIndexOf( revComponents, comp );\n            offset.x = canvasEvent.x - comp.x;\n            offset.y = canvasEvent.y - comp.y;\n\n            canvasDOM.addEventListener('mouseup', onMouseUp );\n            break;\n        }\n\n        if( ! isResizing && dragCompIndex !== -1 ) {\n            const selectionBoxes = getSelectionBoxCords( compDimension );\n            // Loop each selection boxes for hit.\n            selectionBoxes.every( ( box, index ) => {\n                if( rectCollision(canvasEvent.x, canvasEvent.y, box ) ) {\n                    isResizing = true;\n                    prevCursorPos = { ...canvasEvent };\n                    resizePrevCompPos = { ...compDimension };\n                    resizeBoxIndex = index;\n\n                    canvasDOM.addEventListener('mouseup', onMouseUp );\n                    return false;\n                }\n\n                return true;\n            } )\n            // Break loop for components if resizing.\n            if( isResizing ) {\n                break;\n            }\n        }\n    }\n\n    if( ! isDragging && ! isResizing ) {\n        dragCompIndex = -1;\n        resizeBoxIndex = -1;\n    }\n    triggerComponentSelect();\n}\n\n/**\n * Mouse move event.\n * \n * @param event MouseEvent\n */\nconst onMouseMove = ( event: MouseEvent ): void => {\n    const canvasEvent = getCanvasCursorPos( event );\n\n    if( listenMovingCanvas ) {\n        if( isMovingCanvas ) {\n\n            // Move canvas.\n            let cursorChangeX = prevCursorPos.x - canvasEvent.x;\n            let cursorChangeY = prevCursorPos.y - canvasEvent.y;\n\n            for( let index = 0; index < cwComponents.length; index++ ) {\n                cwComponents[index].x = tempComponents[index].x - cursorChangeX;\n                cwComponents[index].y = tempComponents[index].y - cursorChangeY;\n            }\n            cwRender();\n        }\n    } else if( isDragging && ! isResizing && dragCompIndex !== -1 ) {\n\n        // Drag component.\n        cwComponents[dragCompIndex].x = canvasEvent.x - offset.x;\n        cwComponents[dragCompIndex].y = canvasEvent.y - offset.y;\n        cwRender();\n    } else if( isResizing && dragCompIndex !== -1 ) {\n\n        // Resize box draw.\n        let cursorChangeX = prevCursorPos.x - canvasEvent.x;\n        let cursorChangeY = prevCursorPos.y - canvasEvent.y;\n\n        let cursorChangeReverseX = canvasEvent.x - prevCursorPos.x;\n        let cursorChangeReverseY = canvasEvent.y - prevCursorPos.y;\n\n        if( [ 0, 6, 7 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].x = resizePrevCompPos.x - cursorChangeX;\n            cwComponents[dragCompIndex].w = resizePrevCompPos.w + cursorChangeX;\n        }\n        if( [ 0, 1, 2 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].y = resizePrevCompPos.y - cursorChangeY;\n            cwComponents[dragCompIndex].h = resizePrevCompPos.h + cursorChangeY;\n        }\n        if( [ 2, 3, 4 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].w = resizePrevCompPos.w + cursorChangeReverseX;\n        }\n        if( [ 4, 5, 6 ].includes( resizeBoxIndex ) ) {\n            cwComponents[dragCompIndex].h = resizePrevCompPos.h + cursorChangeReverseY;\n        }\n\n        // Maintain minimum weidth and height.\n        if( cwComponents[dragCompIndex].w <= BOX_MIN_WIDTH ) {\n            cwComponents[dragCompIndex].w = BOX_MIN_WIDTH;\n        }\n        if( cwComponents[dragCompIndex].h <= BOX_MIN_HEIGHT ) {\n            cwComponents[dragCompIndex].h = BOX_MIN_HEIGHT;\n        }\n\n        cwRender();\n    } else {\n        cwComponents.every( ( comp, index ) => {\n            let compDimension = {\n                x: comp.x,\n                y: comp.y,\n                w: 0,\n                h: 0,\n            }\n    \n            switch( comp.type ) {\n                case 'box':\n                    const c = comp as BoxComponent;\n                    compDimension.w = c.w;\n                    compDimension.h = c.h;\n                    break;\n            }\n\n            if( rectCollision(canvasEvent.x, canvasEvent.y, compDimension ) ) {\n                canvasDOM.style.cursor = 'move'; // On hover over draggable box.\n                return false;\n            }\n\n            canvasDOM.style.cursor = 'default';\n\n            let selectionBoxActive = false;\n            if( index === dragCompIndex ) {\n                const selectionBoxes = getSelectionBoxCords( compDimension );\n                selectionBoxes.every( ( box, index ) => {\n                    if( rectCollision(canvasEvent.x, canvasEvent.y, box ) ) {\n                        canvasDOM.style.cursor = SELECTION_RESIZE_BOX_CURSORS[index] || 'move';\n                        selectionBoxActive = true;\n                        return false;\n                    }\n                    return true;\n                } )\n            }\n\n            if( selectionBoxActive ) return false;\n            return true;\n        } );\n    }\n}\n\n/**\n * Mouse up event.\n */\nconst onMouseUp = (): void => {\n    if ( isMovingCanvas ) {\n        canvasDOM.style.cursor = 'grab';\n    }\n    isDragging = false;\n    isResizing = false;\n    isMovingCanvas = false;\n    tempComponents = [];\n    canvasDOM.removeEventListener('mouseup', onMouseUp );\n}\n\n/**\n * Key down event.\n * \n * @param event KeyboardEvent\n */\nconst onKeyDown = ( event: KeyboardEvent ): void => {\n    event.preventDefault();\n    if( event.key === ' ' && ! listenMovingCanvas ) {\n        canvasDOM.style.cursor = 'grab'\n        listenMovingCanvas = true;\n    } \n}\n\n/**\n * Key up event.\n * \n * @param event KeyboardEvent\n */\nconst onKeyUp = ( event: KeyboardEvent ): void => {\n    if( event.key === ' ' ) {\n        listenMovingCanvas = false;\n        isMovingCanvas = false;\n        tempComponents = [];\n        canvasDOM.style.cursor = 'default'\n    }\n}\n\n/**\n * Rectangular collision detection.\n * \n * @param x Cursor X.\n * @param y Cursor Y\n * @param rect Rectangle coords.\n * @returns boolean\n */\nconst rectCollision = ( x: number, y: number, rect: { x: number, y: number, w: number, h: number } ): boolean => {\n    if(\n        x > rect.x\n        && y > rect.y\n        && x < ( rect.w + rect.x )\n        && y < ( rect.h + rect.y )\n    ) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Get cursor position in canvas.\n * \n * @param event MouseEvent\n * @returns object\n */\nconst getCanvasCursorPos = ( event: MouseEvent ): { x: number, y: number} => {\n    const canvasRect = canvasDOM.getBoundingClientRect();\n    return { x: event.clientX - canvasRect.left, y: event.clientY - canvasRect.top }\n}\n\n/**\n * Trigger component select event. 'cwComponentSelected'\n */\nconst triggerComponentSelect = (): void => {\n    if( canvasDOM ) {\n        const event = new CustomEvent('cwComponentSelected', { \n            detail:  { \n                index: dragCompIndex, \n                component: cwComponents[dragCompIndex] \n            } \n        });\n        canvasDOM.dispatchEvent( event );\n    }\n}","import { BoxComponent, CanvasComponent, CanvasData } from \"../Dtos/canvas.dtos\";\nimport { debounce, log } from \"./common.utils\";\nimport { DestroyDraggable, RegisterDraggable } from \"./draggable.utils\";\nimport { TimeLogger } from \"./timeLogger.utils\";\nimport { drawBoxComponent, drawSelectionHandle } from './draw.utils';\n\nlet forceStopDebug = true;\nlet debug = ! forceStopDebug && process.env.NODE_ENV === 'development';\n\nlet parentDOM: HTMLDivElement;\nlet canvasDOM: HTMLCanvasElement;\nlet ctx: CanvasRenderingContext2D | null;\nlet cwMode: 'editor' | 'viewer';\n\nlet canvasDefaultData = {\n    height: 500,\n    background: '#f5f5f5',\n    hoverColor: '#0000ff',\n    strokeColor: '#000000',\n    selectionStrokeColor: '#7f7f7f',\n    selectionLineWidth: 1,\n    lineWidth: 1,\n    fontSize: 16,\n    fontFamily: 'Arial',\n    borderRadius: 3,\n}\n\nlet canvasData: CanvasData = {}\nlet selectedIndex: number;\n\ninterface InitCanvasProps {\n    parent: HTMLDivElement,\n    canvas: HTMLCanvasElement,\n    mode?: 'editor' | 'viewer',\n    data?: CanvasData,\n}\n\n/**\n * Initialize Canvas.\n * \n * @param parent Parent DOM.\n * @param canvas Main Canvas DOM.\n * @param mode Mode of canvas workflow.\n * @param data Canvas Data. \n */\nexport const InitCanvas = (\n    { \n        parent,\n        canvas,\n        mode,\n        data,\n    } : InitCanvasProps\n) => {\n    parentDOM = parent;\n    canvasDOM = canvas;\n    cwMode = mode || 'editor';\n\n    ctx = canvas.getContext(\"2d\");\n\n    if( data ) {\n        canvasData = data;\n    }\n    \n    canvasRender();\n    if( cwMode === 'editor' && canvasData?.components?.length ) {\n        RegisterDraggable( canvasDOM, canvasData.components, canvasRender );\n    } else {\n        DestroyDraggable();\n    }\n    window.addEventListener( 'resize', debouncRender );\n    canvasDOM.addEventListener( 'cwComponentSelected', handleComponentSelect );\n}\n\n/**\n * Destroy the canvas events.\n */\nexport const DestroyCanvas = () => {\n    window.removeEventListener( 'resize', debouncRender );\n    canvasDOM.removeEventListener( 'cwComponentSelected', handleComponentSelect );\n    DestroyDraggable();\n    if( debug ) {\n        log('Canvas Destroyed');\n    }\n}\n\n/**\n * Clear Canvas.\n */\nexport const ClearCanvas = () => {\n    if( canvasDOM && ctx ) {\n        ctx.clearRect(0, 0, canvasDOM.width, canvasDOM.height);\n        if( debug ) {\n            log('Canvas Cleared!');\n        }\n    }\n}\n\nconst handleComponentSelect = ( event: CustomEvent ) => {\n    selectedIndex = event.detail.index;\n    canvasRender();\n}\n\n/**\n * Debounce the render function for performance optimization.\n */\nconst debouncRender = debounce( () => canvasRender() );\n\n/**\n * Main render function for canvas.\n */\nconst canvasRender = ( ) => {\n    if( parentDOM && canvasDOM && ctx ) {\n        let parentDim = parentDOM.getBoundingClientRect();\n        canvasDOM.width = parentDim.width;\n        canvasDOM.height = canvasData.height || canvasDefaultData.height;\n    \n        ClearCanvas();\n    \n        if( debug ) {\n            log('Rendering...');\n            log('Data:', {canvasData, canvasDefaultData} );\n            TimeLogger.start();\n        }\n        \n        setCanvasBG();\n\n        if( canvasData?.components ) {\n            canvasData.components.forEach( ( component ) => {\n                renderComponents(component);\n            } );\n        }\n\n        if( debug ) {\n            TimeLogger.stop('Render');\n            log('Render Completed');\n        }\n    }\n}\n\n/**\n * Fill background of canvas.\n */\nconst setCanvasBG = () => {\n    if( canvasDOM && ctx ) {\n        ctx.translate(0.5, 0.5); // Smoothening canvas.\n        ctx.fillStyle = canvasData.background || canvasDefaultData.background;\n        ctx.fillRect(0, 0, canvasDOM.width, canvasDOM.height);\n    }\n}\n\n/**\n * Render component in canvas.\n * @param component Canvas Component\n */\nconst renderComponents = ( component: CanvasComponent ) => {\n    processBaseComponent( component );\n    switch( component.type ) {\n        case 'box':\n            drawBoxComponent( component as BoxComponent, canvasDefaultData, ctx );\n            break;\n    }\n    drawSelectionHandle( component, canvasData, selectedIndex, canvasDefaultData, cwMode, ctx );\n}\n\n/**\n * Process Base of component.\n * \n * @param component Canvas Component.\n */\nconst processBaseComponent = ( component: CanvasComponent ) => {\n    // Register editor mode.\n    if( cwMode === 'editor' ) {\n        \n    }\n}","import { SELECTION_BOX_OFFSET } from \"../Constants/canvas.constants\";\nimport { BorderRadius, BoxComponent, CanvasComponent, CanvasData } from \"../Dtos/canvas.dtos\";\nimport { formatBorderRadius, getSelectionBoxCords, log } from \"./common.utils\";\n\n\n/**\n * Draw Box component.\n * \n * @param component Box Component\n * @returns void\n */\nexport const drawBoxComponent = ( component: BoxComponent, canvasDefaultData: any,  ctx?: CanvasRenderingContext2D | null ) => {\n    if( ! ctx ) return;\n\n    const padding = 5;\n    const fontSize = component.fontSize || canvasDefaultData.fontSize;\n\n    ctx.save(); // Save the default state to restore later.\n    ctx.beginPath();\n    drawRoundedRect( ctx, component.x, component.y, component.w, component.h, component.borderRadius || canvasDefaultData.borderRadius );\n    if( component.fillColor ) {\n        // Draw box fill\n        ctx.fillStyle = component.fillColor;\n        ctx.fill();\n    }\n\n    // Draw box stroke or border.\n    ctx.lineWidth = component.lineWidth || canvasDefaultData.lineWidth;\n    ctx.strokeStyle = component.strokeColor || component.fillColor || canvasDefaultData.strokeColor;\n    ctx.stroke();\n    ctx.clip(); // Clip inner elements inside box.\n\n    // Draw box text.\n    ctx.font = `${fontSize}px ${component.fontFamily}`;\n    ctx.fillStyle = component.textColor || canvasDefaultData.strokeColor;\n    ctx.fillText( \n        component.title, \n        component.x + padding + ctx.lineWidth, \n        component.y + padding + fontSize + ctx.lineWidth - 5,\n    );\n    \n    if( component.description ) {\n        printAtWordWrap( \n            ctx,\n            component.description,\n            component.x + padding + ctx.lineWidth,\n            component.y + (padding * 2) + (fontSize * 2) + ctx.lineWidth - 5,\n            fontSize,\n            component.w - (padding * 2) - ctx.lineWidth,\n        );\n    }\n    ctx.restore(); // Restore default state.\n}\n\n\nexport const drawRoundedRect = ( ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, borderRadius?: BorderRadius ) => {\n    const radius = formatBorderRadius( borderRadius );\n    ctx.moveTo(x + radius.tl, y);\n    ctx.lineTo(x + width - radius.tr, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\n    ctx.lineTo(x + width, y + height - radius.br);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\n    ctx.lineTo(x + radius.bl, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\n    ctx.lineTo(x, y + radius.tl);\n    ctx.quadraticCurveTo(x, y, x + radius.tl, y);\n    ctx.closePath();\n}\n\n/**\n * Draw box selection border or indicator.\n * \n * @param component Canvas Component\n */\nexport const drawSelectionHandle = ( component: CanvasComponent, canvasData: CanvasData, selectedIndex: number, canvasDefaultData: any, cwMode: 'editor' | 'viewer', ctx?: CanvasRenderingContext2D | null ) => {\n    if( \n        ctx \n        && cwMode === 'editor'\n        && selectedIndex > -1 \n        && canvasData.components?.length \n        && selectedIndex === canvasData.components.indexOf(component) \n    ) {\n        let dashedLine = true;\n        let compDimension = {\n            x: component.x,\n            y: component.y,\n            w: 0,\n            h: 0,\n        }\n\n        switch( component.type ) {\n            case 'box':\n                const comp = component as BoxComponent;\n                compDimension.w = comp.w;\n                compDimension.h = comp.h;\n                // dashedLine = false;\n                break;\n        }\n\n        // Draw border for selections.\n        ctx.save();\n        ctx.beginPath();\n        ctx.lineWidth = canvasData.selectionLineWidth || canvasDefaultData.selectionLineWidth;\n        if( dashedLine ) {\n            ctx.setLineDash([5, 5])\n        }\n        ctx.strokeStyle = canvasData.selectionStrokeColor || canvasDefaultData.selectionStrokeColor;\n        ctx.rect( \n            compDimension.x - SELECTION_BOX_OFFSET, \n            compDimension.y - SELECTION_BOX_OFFSET,\n            compDimension.w + (SELECTION_BOX_OFFSET * 2),\n            compDimension.h + (SELECTION_BOX_OFFSET * 2),\n        )\n        ctx.stroke();\n        ctx.restore();\n\n        // Draw border points\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = canvasData.selectionStrokeColor || canvasDefaultData.selectionStrokeColor;\n        \n        const selectionBoxes = getSelectionBoxCords( compDimension );\n        for( let box of selectionBoxes ) {\n            ctx.rect( box.x, box.y, box.w, box.h );\n        }\n\n        ctx.fill();\n        ctx.restore();\n    }\n}\n\nexport const printAtWordWrap = ( ctx: CanvasRenderingContext2D , text: string, x: number, y: number, lineHeight: number, fitWidth?: number) => {\n    fitWidth = fitWidth || 0;\n    \n    if (fitWidth <= 0)\n    {\n        ctx.fillText( text, x, y );\n        return;\n    }\n    var words = text.split(' ');\n    var currentLine = 0;\n    var idx = 1;\n    while (words.length > 0 && idx <= words.length)\n    {\n        var str = words.slice(0,idx).join(' ');\n        var w = ctx.measureText(str).width;\n        if ( w > fitWidth )\n        {\n            if (idx==1)\n            {\n                idx=2;\n            }\n            ctx.fillText( words.slice(0,idx-1).join(' '), x, y + (lineHeight * currentLine) );\n            currentLine++;\n            words = words.splice(idx-1);\n            idx = 1;\n        }\n        else\n        {idx++;}\n    }\n    if  (idx > 0)\n        ctx.fillText( words.join(' '), x, y + (lineHeight * currentLine) );\n}","import React, { createRef, useEffect, useState } from 'react'\nimport { BoxComponent, CanvasData } from './Dtos/canvas.dtos';\nimport './styles.scss'\nimport { DestroyCanvas, InitCanvas } from './Utils/canvas.utils';\nimport { log } from './Utils/common.utils';\n\ninterface Props {\n    mode?: 'editor' | 'viewer';\n    defaultData?: CanvasData;\n    data?: CanvasData;\n    onDataChange?( data: CanvasData ): void;\n}\n\nconst ConvasWorkflow = ({ mode = 'editor', defaultData, data, onDataChange }: Props) => {\n\n    const [cwMode, setCwMode] = useState(mode);\n    const [cwData, setCwData] = useState<CanvasData | undefined>(data || defaultData);\n\n    const canvasRef = createRef<HTMLCanvasElement>();\n    const parentRef = createRef<HTMLDivElement>();\n\n    useEffect(() => {\n        setCwMode(mode);\n        setCwData(data);\n    }, [mode, data])\n\n    useEffect(() => {\n        if( canvasRef.current && parentRef.current ) {\n            InitCanvas({\n                parent: parentRef.current,\n                canvas: canvasRef.current,\n                mode: cwMode,\n                data: cwData,\n            });\n        }\n\n        return () => {\n            DestroyCanvas();\n        }\n    }, [canvasRef, parentRef, cwMode, cwData ])\n\n    const addRandomBox = () => {\n        const randomX = Math.floor( Math.random() * ( canvasRef.current?.width || 100 ) );\n        const randomY = Math.floor( Math.random() * ( canvasRef.current?.height || 100 ) );\n        // const randomRadius = Math.floor( Math.random() * 15 );\n\n        const comp: BoxComponent = {\n            type: 'box',\n            title: 'Random',\n            description: 'Random ' + randomX + ':' + randomY,\n            x: randomX,\n            y: randomY,\n            w: 150,\n            h: 100,\n            fillColor: '#ffffff',\n            strokeColor: '#ccc',\n            borderRadius: 2,\n        }\n        setCwData( { ...cwData, components: [ ...cwData?.components || [], comp ] })\n    }\n\n    const clearAll = () => {\n        setCwData( { ...cwData, components: [] } );\n    }\n\n    return (\n        <div className={`canvas-workflow`} >\n            <div className='cw-tools'>\n                <div className=''>\n                    <div>Tool Box</div>\n                </div>\n            </div>\n            <div className='cw-wrapper' ref={parentRef}>\n                <canvas ref={canvasRef} tabIndex={1}></canvas>\n            </div>\n            <div className='cw-settings'>\n                <div onClick={()=>setCwMode('viewer')}>settings</div>\n                <button onClick={addRandomBox}>Add Random Box</button>\n                <button onClick={clearAll}>Clear All</button>\n            </div>\n        </div>\n    )\n}\n\nexport default ConvasWorkflow;","import React, { useEffect, useState } from 'react'\n\nimport CanvasWorkflow from 'canvas-workflow'\nimport { CanvasData } from 'canvas-workflow/dist/Dtos/canvas.dtos'\nimport 'canvas-workflow/dist/index.css'\n\nconst App = () => {\n    const [data, setData] = useState<CanvasData>();\n\n    useEffect(() => {\n        setData({\n            components:[\n                { \n                    type: 'box',\n                    title: 'Rumesh',\n                    description: 'Hello my name is rumesh udash',\n                    x: 100,\n                    y: 100,\n                    w: 150,\n                    h: 100,\n                    fillColor: 'red',\n                    strokeColor: 'green',\n                    lineWidth: 1,\n                    borderRadius: 5,\n                }\n            ]\n        })\n    }, [])\n\n    const dataChangeHandle = ( data: CanvasData ) => {\n        setData( data );\n    }\n\n    return (\n        <div>\n            <CanvasWorkflow mode='editor' data={data} onDataChange={dataChangeHandle} />\n            {/* <CanvasWorkflow mode='viewer' data={data} /> */}\n        </div>\n    )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}